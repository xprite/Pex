   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"IO1.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  19              		.align	2
  22              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  23 0000 00000000 		.space	24
  23      00000000 
  23      00000000 
  23      00000000 
  23      00000000 
  24              		.section	.text.IO1_Init,"ax",%progbits
  25              		.align	2
  26              		.global	IO1_Init
  27              		.thumb
  28              		.thumb_func
  30              	IO1_Init:
  31              	.LFB0:
  32              		.file 1 "../Generated_Code/IO1.c"
   1:../Generated_Code/IO1.c **** /** ###################################################################
   2:../Generated_Code/IO1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/IO1.c **** **     Filename    : IO1.c
   4:../Generated_Code/IO1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/IO1.c **** **     Processor   : MK40DX256ZVLQ10
   6:../Generated_Code/IO1.c **** **     Component   : Serial_LDD
   7:../Generated_Code/IO1.c **** **     Version     : Component 01.165, Driver 01.10, CPU db: 3.00.001
   8:../Generated_Code/IO1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/IO1.c **** **     Date/Time   : 2013-04-11, 15:40, # CodeGen: 91
  10:../Generated_Code/IO1.c **** **     Abstract    :
  11:../Generated_Code/IO1.c **** **         This component "Serial_LDD" implements an asynchronous serial
  12:../Generated_Code/IO1.c **** **         communication. The component supports different settings of
  13:../Generated_Code/IO1.c **** **         parity, word width, stop-bit and communication speed,
  14:../Generated_Code/IO1.c **** **         user can select interrupt or polling handler.
  15:../Generated_Code/IO1.c **** **         Communication speed can be changed also in runtime.
  16:../Generated_Code/IO1.c **** **         The component requires one on-chip asynchronous serial communication channel.
  17:../Generated_Code/IO1.c **** **     Settings    :
  18:../Generated_Code/IO1.c **** **          Component name                                 : IO1
  19:../Generated_Code/IO1.c **** **          Device                                         : UART0
  20:../Generated_Code/IO1.c **** **          Interrupt service/event                        : Disabled
  21:../Generated_Code/IO1.c **** **          Settings                                       : 
  22:../Generated_Code/IO1.c **** **            Data width                                   : 8 bits
  23:../Generated_Code/IO1.c **** **            Parity                                       : None
  24:../Generated_Code/IO1.c **** **            Stop bits                                    : 1
  25:../Generated_Code/IO1.c **** **            Loop mode                                    : Normal
  26:../Generated_Code/IO1.c **** **            Baud rate                                    : 115200 baud
  27:../Generated_Code/IO1.c **** **            Wakeup condition                             : Idle line wakeup
  28:../Generated_Code/IO1.c **** **            Stop in wait mode                            : no
  29:../Generated_Code/IO1.c **** **            Idle line mode                               : Starts after start bit
  30:../Generated_Code/IO1.c **** **            Transmitter output                           : Not inverted
  31:../Generated_Code/IO1.c **** **            Receiver input                               : Not inverted
  32:../Generated_Code/IO1.c **** **            Break generation length                      : 10/11 bits
  33:../Generated_Code/IO1.c **** **            Receiver                                     : Enabled
  34:../Generated_Code/IO1.c **** **              RxD                                        : PTA15/SPI0_SCK/UART0_RX/FB_AD30/I2S0_R
  35:../Generated_Code/IO1.c **** **              RxD pin signal                             : 
  36:../Generated_Code/IO1.c **** **            Transmitter                                  : Enabled
  37:../Generated_Code/IO1.c **** **              TxD                                        : PTA14/SPI0_PCS0/UART0_TX/FB_AD31/I2S0_
  38:../Generated_Code/IO1.c **** **              TxD pin signal                             : 
  39:../Generated_Code/IO1.c **** **            Flow control                                 : None
  40:../Generated_Code/IO1.c **** **          Initialization                                 : 
  41:../Generated_Code/IO1.c **** **            Enabled in init. code                        : yes
  42:../Generated_Code/IO1.c **** **            Auto initialization                          : yes
  43:../Generated_Code/IO1.c **** **            Event mask                                   : 
  44:../Generated_Code/IO1.c **** **              OnBlockSent                                : Disabled
  45:../Generated_Code/IO1.c **** **              OnBlockReceived                            : Disabled
  46:../Generated_Code/IO1.c **** **              OnTxComplete                               : Disabled
  47:../Generated_Code/IO1.c **** **              OnError                                    : Disabled
  48:../Generated_Code/IO1.c **** **              OnBreak                                    : Disabled
  49:../Generated_Code/IO1.c **** **          CPU clock/configuration selection              : 
  50:../Generated_Code/IO1.c **** **            Clock configuration 0                        : This component enabled
  51:../Generated_Code/IO1.c **** **            Clock configuration 1                        : This component enabled
  52:../Generated_Code/IO1.c **** **            Clock configuration 2                        : This component enabled
  53:../Generated_Code/IO1.c **** **            Clock configuration 3                        : This component enabled
  54:../Generated_Code/IO1.c **** **            Clock configuration 4                        : This component enabled
  55:../Generated_Code/IO1.c **** **            Clock configuration 5                        : This component enabled
  56:../Generated_Code/IO1.c **** **            Clock configuration 6                        : This component enabled
  57:../Generated_Code/IO1.c **** **            Clock configuration 7                        : This component enabled
  58:../Generated_Code/IO1.c **** **     Contents    :
  59:../Generated_Code/IO1.c **** **         Init - LDD_TDeviceData* IO1_Init(LDD_TUserData *UserDataPtr);
  60:../Generated_Code/IO1.c **** **         Main - void IO1_Main(LDD_TDeviceData *DeviceDataPtr);
  61:../Generated_Code/IO1.c **** **
  62:../Generated_Code/IO1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  63:../Generated_Code/IO1.c **** **     
  64:../Generated_Code/IO1.c **** **     http      : www.freescale.com
  65:../Generated_Code/IO1.c **** **     mail      : support@freescale.com
  66:../Generated_Code/IO1.c **** ** ###################################################################*/
  67:../Generated_Code/IO1.c **** 
  68:../Generated_Code/IO1.c **** /* MODULE IO1. */
  69:../Generated_Code/IO1.c **** /*lint -save  -e926 -e927 -e928 -e929 -e572 Disable MISRA rule (11.4,12.8) checking. */
  70:../Generated_Code/IO1.c **** 
  71:../Generated_Code/IO1.c **** /* {Default RTOS Adapter} No RTOS includes */
  72:../Generated_Code/IO1.c **** #include "IO1.h"
  73:../Generated_Code/IO1.c **** #include "UART_PDD.h"
  74:../Generated_Code/IO1.c **** 
  75:../Generated_Code/IO1.c **** #define AVAILABLE_EVENTS_MASK 0x00U
  76:../Generated_Code/IO1.c **** 
  77:../Generated_Code/IO1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  78:../Generated_Code/IO1.c **** static IO1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  79:../Generated_Code/IO1.c **** 
  80:../Generated_Code/IO1.c **** /*
  81:../Generated_Code/IO1.c **** ** ===================================================================
  82:../Generated_Code/IO1.c **** **     Method      :  IO1_Init (component Serial_LDD)
  83:../Generated_Code/IO1.c **** **
  84:../Generated_Code/IO1.c **** **     Description :
  85:../Generated_Code/IO1.c **** **         Initializes the device. Allocates memory for the device data
  86:../Generated_Code/IO1.c **** **         structure, allocates interrupt vectors and sets interrupt
  87:../Generated_Code/IO1.c **** **         priority, sets pin routing, sets timing, etc. If the "Enable
  88:../Generated_Code/IO1.c **** **         in init. code" is set to "yes" value then the device is also
  89:../Generated_Code/IO1.c **** **         enabled(see the description of the Enable() method). In this
  90:../Generated_Code/IO1.c **** **         case the Enable() method is not necessary and needn't to be
  91:../Generated_Code/IO1.c **** **         generated. 
  92:../Generated_Code/IO1.c **** **     Parameters  :
  93:../Generated_Code/IO1.c **** **         NAME            - DESCRIPTION
  94:../Generated_Code/IO1.c **** **       * UserDataPtr     - Pointer to the user or
  95:../Generated_Code/IO1.c **** **                           RTOS specific data. This pointer will be
  96:../Generated_Code/IO1.c **** **                           passed as an event or callback parameter.
  97:../Generated_Code/IO1.c **** **     Returns     :
  98:../Generated_Code/IO1.c **** **         ---             - Device data structure pointer.
  99:../Generated_Code/IO1.c **** ** ===================================================================
 100:../Generated_Code/IO1.c **** */
 101:../Generated_Code/IO1.c **** LDD_TDeviceData* IO1_Init(LDD_TUserData *UserDataPtr)
 102:../Generated_Code/IO1.c **** {
  33              		.loc 1 102 0
  34              		.cfi_startproc
  35              		@ args = 0, pretend = 0, frame = 16
  36              		@ frame_needed = 1, uses_anonymous_args = 0
  37              		@ link register save eliminated.
  38 0000 80B4     		push	{r7}
  39              	.LCFI0:
  40              		.cfi_def_cfa_offset 4
  41              		.cfi_offset 7, -4
  42 0002 85B0     		sub	sp, sp, #20
  43              	.LCFI1:
  44              		.cfi_def_cfa_offset 24
  45 0004 00AF     		add	r7, sp, #0
  46              	.LCFI2:
  47              		.cfi_def_cfa_register 7
  48 0006 7860     		str	r0, [r7, #4]
 103:../Generated_Code/IO1.c ****   /* Allocate device structure */
 104:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv;
 105:../Generated_Code/IO1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 106:../Generated_Code/IO1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  49              		.loc 1 106 0
  50 0008 40F20003 		movw	r3, #:lower16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  51 000c C0F20003 		movt	r3, #:upper16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  52 0010 FB60     		str	r3, [r7, #12]
 107:../Generated_Code/IO1.c **** 
 108:../Generated_Code/IO1.c ****   /* Clear the receive counters and pointer */
 109:../Generated_Code/IO1.c ****   DeviceDataPrv->InpRecvDataNum = 0x00U; /* Clear the counter of received characters */
  53              		.loc 1 109 0
  54 0012 FB68     		ldr	r3, [r7, #12]
  55 0014 4FF00002 		mov	r2, #0
  56 0018 5A80     		strh	r2, [r3, #2]	@ movhi
 110:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataNumReq = 0x00U; /* Clear the counter of characters to receive by ReceiveBlo
  57              		.loc 1 110 0
  58 001a FB68     		ldr	r3, [r7, #12]
  59 001c 4FF00002 		mov	r2, #0
  60 0020 1A81     		strh	r2, [r3, #8]	@ movhi
 111:../Generated_Code/IO1.c ****   DeviceDataPrv->InpDataPtr = NULL;    /* Clear the buffer pointer for received characters */
  61              		.loc 1 111 0
  62 0022 FB68     		ldr	r3, [r7, #12]
  63 0024 4FF00002 		mov	r2, #0
  64 0028 5A60     		str	r2, [r3, #4]
 112:../Generated_Code/IO1.c ****   /* Clear the transmit counters and pointer */
 113:../Generated_Code/IO1.c ****   DeviceDataPrv->OutSentDataNum = 0x00U; /* Clear the counter of sent characters */
  65              		.loc 1 113 0
  66 002a FB68     		ldr	r3, [r7, #12]
  67 002c 4FF00002 		mov	r2, #0
  68 0030 5A81     		strh	r2, [r3, #10]	@ movhi
 114:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBlock(
  69              		.loc 1 114 0
  70 0032 FB68     		ldr	r3, [r7, #12]
  71 0034 4FF00002 		mov	r2, #0
  72 0038 1A82     		strh	r2, [r3, #16]	@ movhi
 115:../Generated_Code/IO1.c ****   DeviceDataPrv->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  73              		.loc 1 115 0
  74 003a FB68     		ldr	r3, [r7, #12]
  75 003c 4FF00002 		mov	r2, #0
  76 0040 DA60     		str	r2, [r3, #12]
 116:../Generated_Code/IO1.c ****   DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
  77              		.loc 1 116 0
  78 0042 FB68     		ldr	r3, [r7, #12]
  79 0044 7A68     		ldr	r2, [r7, #4]
  80 0046 5A61     		str	r2, [r3, #20]
 117:../Generated_Code/IO1.c ****   /* SIM_SCGC4: UART0=1 */
 118:../Generated_Code/IO1.c ****   SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;                                                   
  81              		.loc 1 118 0
  82 0048 4FF4E043 		mov	r3, #28672
  83 004c C4F20403 		movt	r3, 16388
  84 0050 4FF4E042 		mov	r2, #28672
  85 0054 C4F20402 		movt	r2, 16388
  86 0058 02F58052 		add	r2, r2, #4096
  87 005c 02F13402 		add	r2, r2, #52
  88 0060 1268     		ldr	r2, [r2, #0]
  89 0062 42F48062 		orr	r2, r2, #1024
  90 0066 03F58053 		add	r3, r3, #4096
  91 006a 03F13403 		add	r3, r3, #52
  92 006e 1A60     		str	r2, [r3, #0]
 119:../Generated_Code/IO1.c ****   /* PORTA_PCR15: ISF=0,MUX=3 */
 120:../Generated_Code/IO1.c ****   PORTA_PCR15 = (uint32_t)((PORTA_PCR15 & (uint32_t)~(uint32_t)(
  93              		.loc 1 120 0
  94 0070 4FF41043 		mov	r3, #36864
  95 0074 C4F20403 		movt	r3, 16388
  96 0078 4FF41042 		mov	r2, #36864
  97 007c C4F20402 		movt	r2, 16388
  98 0080 D26B     		ldr	r2, [r2, #60]
  99 0082 22F08072 		bic	r2, r2, #16777216
 100 0086 22F4E062 		bic	r2, r2, #1792
 101 008a 42F44072 		orr	r2, r2, #768
 102 008e DA63     		str	r2, [r3, #60]
 121:../Generated_Code/IO1.c ****                  PORT_PCR_ISF_MASK |
 122:../Generated_Code/IO1.c ****                  PORT_PCR_MUX(0x04)
 123:../Generated_Code/IO1.c ****                 )) | (uint32_t)(
 124:../Generated_Code/IO1.c ****                  PORT_PCR_MUX(0x03)
 125:../Generated_Code/IO1.c ****                 ));                                                  
 126:../Generated_Code/IO1.c ****   /* PORTA_PCR14: ISF=0,MUX=3 */
 127:../Generated_Code/IO1.c ****   PORTA_PCR14 = (uint32_t)((PORTA_PCR14 & (uint32_t)~(uint32_t)(
 103              		.loc 1 127 0
 104 0090 4FF41043 		mov	r3, #36864
 105 0094 C4F20403 		movt	r3, 16388
 106 0098 4FF41042 		mov	r2, #36864
 107 009c C4F20402 		movt	r2, 16388
 108 00a0 926B     		ldr	r2, [r2, #56]
 109 00a2 22F08072 		bic	r2, r2, #16777216
 110 00a6 22F4E062 		bic	r2, r2, #1792
 111 00aa 42F44072 		orr	r2, r2, #768
 112 00ae 9A63     		str	r2, [r3, #56]
 128:../Generated_Code/IO1.c ****                  PORT_PCR_ISF_MASK |
 129:../Generated_Code/IO1.c ****                  PORT_PCR_MUX(0x04)
 130:../Generated_Code/IO1.c ****                 )) | (uint32_t)(
 131:../Generated_Code/IO1.c ****                  PORT_PCR_MUX(0x03)
 132:../Generated_Code/IO1.c ****                 ));                                                  
 133:../Generated_Code/IO1.c ****   UART_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_DISABLE); /* Disable transmitter. */
 113              		.loc 1 133 0
 114 00b0 4FF42043 		mov	r3, #40960
 115 00b4 C4F20603 		movt	r3, 16390
 116 00b8 4FF42042 		mov	r2, #40960
 117 00bc C4F20602 		movt	r2, 16390
 118 00c0 D278     		ldrb	r2, [r2, #3]
 119 00c2 D2B2     		uxtb	r2, r2
 120 00c4 22F00802 		bic	r2, r2, #8
 121 00c8 D2B2     		uxtb	r2, r2
 122 00ca DA70     		strb	r2, [r3, #3]
 134:../Generated_Code/IO1.c ****   UART_PDD_EnableReceiver(UART0_BASE_PTR, PDD_DISABLE); /* Disable receiver. */
 123              		.loc 1 134 0
 124 00cc 4FF42043 		mov	r3, #40960
 125 00d0 C4F20603 		movt	r3, 16390
 126 00d4 4FF42042 		mov	r2, #40960
 127 00d8 C4F20602 		movt	r2, 16390
 128 00dc D278     		ldrb	r2, [r2, #3]
 129 00de D2B2     		uxtb	r2, r2
 130 00e0 22F00402 		bic	r2, r2, #4
 131 00e4 D2B2     		uxtb	r2, r2
 132 00e6 DA70     		strb	r2, [r3, #3]
 135:../Generated_Code/IO1.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset flags */
 133              		.loc 1 135 0
 134 00e8 FB68     		ldr	r3, [r7, #12]
 135 00ea 4FF00002 		mov	r2, #0
 136 00ee 1A80     		strh	r2, [r3, #0]	@ movhi
 136:../Generated_Code/IO1.c ****   /* UART0_C1: LOOPS=0,UARTSWAI=0,RSRC=0,M=0,WAKE=0,ILT=0,PE=0,PT=0 */
 137:../Generated_Code/IO1.c ****   UART0_C1 = 0x00U;                    /*  Set the C1 register */
 137              		.loc 1 137 0
 138 00f0 4FF42043 		mov	r3, #40960
 139 00f4 C4F20603 		movt	r3, 16390
 140 00f8 4FF00002 		mov	r2, #0
 141 00fc 9A70     		strb	r2, [r3, #2]
 138:../Generated_Code/IO1.c ****   /* UART0_C3: R8=0,T8=0,TXDIR=0,TXINV=0,ORIE=0,NEIE=0,FEIE=0,PEIE=0 */
 139:../Generated_Code/IO1.c ****   UART0_C3 = 0x00U;                    /*  Set the C3 register */
 142              		.loc 1 139 0
 143 00fe 4FF42043 		mov	r3, #40960
 144 0102 C4F20603 		movt	r3, 16390
 145 0106 4FF00002 		mov	r2, #0
 146 010a 9A71     		strb	r2, [r3, #6]
 140:../Generated_Code/IO1.c ****   /* UART0_S2: LBKDIF=0,RXEDGIF=0,MSBF=0,RXINV=0,RWUID=0,BRK13=0,LBKDE=0,RAF=0 */
 141:../Generated_Code/IO1.c ****   UART0_S2 = 0x00U;                    /*  Set the S2 register */
 147              		.loc 1 141 0
 148 010c 4FF42043 		mov	r3, #40960
 149 0110 C4F20603 		movt	r3, 16390
 150 0114 4FF00002 		mov	r2, #0
 151 0118 5A71     		strb	r2, [r3, #5]
 142:../Generated_Code/IO1.c ****   /* UART0_MODEM: ??=0,??=0,??=0,??=0,RXRTSE=0,TXRTSPOL=0,TXRTSE=0,TXCTSE=0 */
 143:../Generated_Code/IO1.c ****   UART0_MODEM = 0x00U;                 /*  Set the MODEM register */
 152              		.loc 1 143 0
 153 011a 4FF42043 		mov	r3, #40960
 154 011e C4F20603 		movt	r3, 16390
 155 0122 4FF00002 		mov	r2, #0
 156 0126 5A73     		strb	r2, [r3, #13]
 144:../Generated_Code/IO1.c ****   UART_PDD_SetBaudRateFineAdjust(UART0_BASE_PTR, 3u); /* Set baud rate fine adjust */
 157              		.loc 1 144 0
 158 0128 4FF42043 		mov	r3, #40960
 159 012c C4F20603 		movt	r3, 16390
 160 0130 4FF42042 		mov	r2, #40960
 161 0134 C4F20602 		movt	r2, 16390
 162 0138 927A     		ldrb	r2, [r2, #10]
 163 013a D2B2     		uxtb	r2, r2
 164 013c D2B2     		uxtb	r2, r2
 165 013e 22F01F02 		bic	r2, r2, #31
 166 0142 D2B2     		uxtb	r2, r2
 167 0144 42F00302 		orr	r2, r2, #3
 168 0148 D2B2     		uxtb	r2, r2
 169 014a D2B2     		uxtb	r2, r2
 170 014c 9A72     		strb	r2, [r3, #10]
 145:../Generated_Code/IO1.c ****   UART_PDD_SetBaudRate(UART0_BASE_PTR, 52U); /* Set the baud rate register. */
 171              		.loc 1 145 0
 172 014e 4FF42043 		mov	r3, #40960
 173 0152 C4F20603 		movt	r3, 16390
 174 0156 4FF42042 		mov	r2, #40960
 175 015a C4F20602 		movt	r2, 16390
 176 015e 1278     		ldrb	r2, [r2, #0]
 177 0160 D2B2     		uxtb	r2, r2
 178 0162 22F01F02 		bic	r2, r2, #31
 179 0166 D2B2     		uxtb	r2, r2
 180 0168 1A70     		strb	r2, [r3, #0]
 181 016a 4FF42043 		mov	r3, #40960
 182 016e C4F20603 		movt	r3, 16390
 183 0172 4FF03402 		mov	r2, #52
 184 0176 5A70     		strb	r2, [r3, #1]
 146:../Generated_Code/IO1.c ****   UART_PDD_EnableFifo(UART0_BASE_PTR, (UART_PDD_TX_FIFO_ENABLE | UART_PDD_RX_FIFO_ENABLE)); /* Enab
 185              		.loc 1 146 0
 186 0178 4FF42043 		mov	r3, #40960
 187 017c C4F20603 		movt	r3, 16390
 188 0180 4FF42042 		mov	r2, #40960
 189 0184 C4F20602 		movt	r2, 16390
 190 0188 127C     		ldrb	r2, [r2, #16]
 191 018a D2B2     		uxtb	r2, r2
 192 018c 62F07702 		orn	r2, r2, #119
 193 0190 D2B2     		uxtb	r2, r2
 194 0192 1A74     		strb	r2, [r3, #16]
 147:../Generated_Code/IO1.c ****   UART_PDD_FlushFifo(UART0_BASE_PTR, (UART_PDD_TX_FIFO_FLUSH | UART_PDD_RX_FIFO_FLUSH)); /* Flush R
 195              		.loc 1 147 0
 196 0194 4FF42043 		mov	r3, #40960
 197 0198 C4F20603 		movt	r3, 16390
 198 019c 4FF42042 		mov	r2, #40960
 199 01a0 C4F20602 		movt	r2, 16390
 200 01a4 527C     		ldrb	r2, [r2, #17]
 201 01a6 D2B2     		uxtb	r2, r2
 202 01a8 62F03F02 		orn	r2, r2, #63
 203 01ac D2B2     		uxtb	r2, r2
 204 01ae 5A74     		strb	r2, [r3, #17]
 148:../Generated_Code/IO1.c ****   UART_PDD_EnableTransmitter(UART0_BASE_PTR, PDD_ENABLE); /* Enable transmitter */
 205              		.loc 1 148 0
 206 01b0 4FF42043 		mov	r3, #40960
 207 01b4 C4F20603 		movt	r3, 16390
 208 01b8 4FF42042 		mov	r2, #40960
 209 01bc C4F20602 		movt	r2, 16390
 210 01c0 D278     		ldrb	r2, [r2, #3]
 211 01c2 D2B2     		uxtb	r2, r2
 212 01c4 D2B2     		uxtb	r2, r2
 213 01c6 42F00802 		orr	r2, r2, #8
 214 01ca D2B2     		uxtb	r2, r2
 215 01cc D2B2     		uxtb	r2, r2
 216 01ce DA70     		strb	r2, [r3, #3]
 149:../Generated_Code/IO1.c ****   UART_PDD_EnableReceiver(UART0_BASE_PTR, PDD_ENABLE); /* Enable receiver */
 217              		.loc 1 149 0
 218 01d0 4FF42043 		mov	r3, #40960
 219 01d4 C4F20603 		movt	r3, 16390
 220 01d8 4FF42042 		mov	r2, #40960
 221 01dc C4F20602 		movt	r2, 16390
 222 01e0 D278     		ldrb	r2, [r2, #3]
 223 01e2 D2B2     		uxtb	r2, r2
 224 01e4 D2B2     		uxtb	r2, r2
 225 01e6 42F00402 		orr	r2, r2, #4
 226 01ea D2B2     		uxtb	r2, r2
 227 01ec D2B2     		uxtb	r2, r2
 228 01ee DA70     		strb	r2, [r3, #3]
 150:../Generated_Code/IO1.c ****   /* Registration of the device structure */
 151:../Generated_Code/IO1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_IO1_ID,DeviceDataPrv);
 229              		.loc 1 151 0
 230 01f0 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 231 01f4 C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 232 01f8 FA68     		ldr	r2, [r7, #12]
 233 01fa 1A61     		str	r2, [r3, #16]
 152:../Generated_Code/IO1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv);
 234              		.loc 1 152 0
 235 01fc FB68     		ldr	r3, [r7, #12]
 153:../Generated_Code/IO1.c **** }
 236              		.loc 1 153 0
 237 01fe 1846     		mov	r0, r3
 238 0200 07F11407 		add	r7, r7, #20
 239 0204 BD46     		mov	sp, r7
 240 0206 80BC     		pop	{r7}
 241 0208 7047     		bx	lr
 242              		.cfi_endproc
 243              	.LFE0:
 245 020a 00BF     		.section	.text.InterruptRx,"ax",%progbits
 246              		.align	2
 247              		.thumb
 248              		.thumb_func
 250              	InterruptRx:
 251              	.LFB1:
 154:../Generated_Code/IO1.c **** 
 155:../Generated_Code/IO1.c **** /*
 156:../Generated_Code/IO1.c **** ** ===================================================================
 157:../Generated_Code/IO1.c **** **     Method      :  InterruptRx (component Serial_LDD)
 158:../Generated_Code/IO1.c **** **
 159:../Generated_Code/IO1.c **** **     Description :
 160:../Generated_Code/IO1.c **** **         The method services the receive interrupt of the selected 
 161:../Generated_Code/IO1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 162:../Generated_Code/IO1.c **** **         This method is internal. It is used by Processor Expert only.
 163:../Generated_Code/IO1.c **** ** ===================================================================
 164:../Generated_Code/IO1.c **** */
 165:../Generated_Code/IO1.c **** static void InterruptRx(IO1_TDeviceDataPtr DeviceDataPrv)
 166:../Generated_Code/IO1.c **** {
 252              		.loc 1 166 0
 253              		.cfi_startproc
 254              		@ args = 0, pretend = 0, frame = 8
 255              		@ frame_needed = 1, uses_anonymous_args = 0
 256              		@ link register save eliminated.
 257 0000 90B4     		push	{r4, r7}
 258              	.LCFI3:
 259              		.cfi_def_cfa_offset 8
 260              		.cfi_offset 7, -4
 261              		.cfi_offset 4, -8
 262 0002 82B0     		sub	sp, sp, #8
 263              	.LCFI4:
 264              		.cfi_def_cfa_offset 16
 265 0004 00AF     		add	r7, sp, #0
 266              	.LCFI5:
 267              		.cfi_def_cfa_register 7
 268 0006 7860     		str	r0, [r7, #4]
 167:../Generated_Code/IO1.c ****   register uint16_t Data;              /* Temporary variable for data */
 168:../Generated_Code/IO1.c **** 
 169:../Generated_Code/IO1.c ****   Data = (uint16_t)UART_PDD_GetChar8(UART0_BASE_PTR); /* Read an 8-bit character from the receiver 
 269              		.loc 1 169 0
 270 0008 4FF42043 		mov	r3, #40960
 271 000c C4F20603 		movt	r3, 16390
 272 0010 DB79     		ldrb	r3, [r3, #7]
 273 0012 DBB2     		uxtb	r3, r3
 274 0014 1C46     		mov	r4, r3
 170:../Generated_Code/IO1.c ****   if (DeviceDataPrv->InpDataNumReq != 0x00U) { /* Is the receive block operation pending? */
 275              		.loc 1 170 0
 276 0016 7B68     		ldr	r3, [r7, #4]
 277 0018 1B89     		ldrh	r3, [r3, #8]
 278 001a 002B     		cmp	r3, #0
 279 001c 18D0     		beq	.L2
 171:../Generated_Code/IO1.c ****     *(DeviceDataPrv->InpDataPtr++) = (uint8_t)Data; /* Put an 8-bit character to the receive buffer
 280              		.loc 1 171 0
 281 001e 7B68     		ldr	r3, [r7, #4]
 282 0020 5B68     		ldr	r3, [r3, #4]
 283 0022 E2B2     		uxtb	r2, r4
 284 0024 1A70     		strb	r2, [r3, #0]
 285 0026 03F10102 		add	r2, r3, #1
 286 002a 7B68     		ldr	r3, [r7, #4]
 287 002c 5A60     		str	r2, [r3, #4]
 172:../Generated_Code/IO1.c ****     DeviceDataPrv->InpRecvDataNum++;   /* Increment received char. counter */
 288              		.loc 1 172 0
 289 002e 7B68     		ldr	r3, [r7, #4]
 290 0030 5B88     		ldrh	r3, [r3, #2]
 291 0032 03F10103 		add	r3, r3, #1
 292 0036 9AB2     		uxth	r2, r3
 293 0038 7B68     		ldr	r3, [r7, #4]
 294 003a 5A80     		strh	r2, [r3, #2]	@ movhi
 173:../Generated_Code/IO1.c ****     if (DeviceDataPrv->InpRecvDataNum == DeviceDataPrv->InpDataNumReq) { /* Is the requested number
 295              		.loc 1 173 0
 296 003c 7B68     		ldr	r3, [r7, #4]
 297 003e 5A88     		ldrh	r2, [r3, #2]
 298 0040 7B68     		ldr	r3, [r7, #4]
 299 0042 1B89     		ldrh	r3, [r3, #8]
 300 0044 9A42     		cmp	r2, r3
 301 0046 03D1     		bne	.L2
 174:../Generated_Code/IO1.c ****       DeviceDataPrv->InpDataNumReq = 0x00U; /* If yes then clear number of requested characters to 
 302              		.loc 1 174 0
 303 0048 7B68     		ldr	r3, [r7, #4]
 304 004a 4FF00002 		mov	r2, #0
 305 004e 1A81     		strh	r2, [r3, #8]	@ movhi
 306              	.L2:
 175:../Generated_Code/IO1.c ****     }
 176:../Generated_Code/IO1.c ****   }
 177:../Generated_Code/IO1.c **** }
 307              		.loc 1 177 0
 308 0050 07F10807 		add	r7, r7, #8
 309 0054 BD46     		mov	sp, r7
 310 0056 90BC     		pop	{r4, r7}
 311 0058 7047     		bx	lr
 312              		.cfi_endproc
 313              	.LFE1:
 315 005a 00BF     		.section	.text.InterruptTx,"ax",%progbits
 316              		.align	2
 317              		.thumb
 318              		.thumb_func
 320              	InterruptTx:
 321              	.LFB2:
 178:../Generated_Code/IO1.c **** 
 179:../Generated_Code/IO1.c **** /*
 180:../Generated_Code/IO1.c **** ** ===================================================================
 181:../Generated_Code/IO1.c **** **     Method      :  InterruptTx (component Serial_LDD)
 182:../Generated_Code/IO1.c **** **
 183:../Generated_Code/IO1.c **** **     Description :
 184:../Generated_Code/IO1.c **** **         The method services the receive interrupt of the selected 
 185:../Generated_Code/IO1.c **** **         peripheral(s) and eventually invokes the bean's event(s).
 186:../Generated_Code/IO1.c **** **         This method is internal. It is used by Processor Expert only.
 187:../Generated_Code/IO1.c **** ** ===================================================================
 188:../Generated_Code/IO1.c **** */
 189:../Generated_Code/IO1.c **** static void InterruptTx(IO1_TDeviceDataPtr DeviceDataPrv)
 190:../Generated_Code/IO1.c **** {
 322              		.loc 1 190 0
 323              		.cfi_startproc
 324              		@ args = 0, pretend = 0, frame = 8
 325              		@ frame_needed = 1, uses_anonymous_args = 0
 326              		@ link register save eliminated.
 327 0000 80B4     		push	{r7}
 328              	.LCFI6:
 329              		.cfi_def_cfa_offset 4
 330              		.cfi_offset 7, -4
 331 0002 83B0     		sub	sp, sp, #12
 332              	.LCFI7:
 333              		.cfi_def_cfa_offset 16
 334 0004 00AF     		add	r7, sp, #0
 335              	.LCFI8:
 336              		.cfi_def_cfa_register 7
 337 0006 7860     		str	r0, [r7, #4]
 191:../Generated_Code/IO1.c **** 
 192:../Generated_Code/IO1.c ****   if (DeviceDataPrv->OutSentDataNum < DeviceDataPrv->OutDataNumReq) { /* Is number of sent characte
 338              		.loc 1 192 0
 339 0008 7B68     		ldr	r3, [r7, #4]
 340 000a 5A89     		ldrh	r2, [r3, #10]
 341 000c 7B68     		ldr	r3, [r7, #4]
 342 000e 1B8A     		ldrh	r3, [r3, #16]
 343 0010 9A42     		cmp	r2, r3
 344 0012 1DD2     		bcs	.L5
 193:../Generated_Code/IO1.c ****     UART_PDD_PutChar8(UART0_BASE_PTR, *(DeviceDataPrv->OutDataPtr++)); /* Put a 8-bit character to 
 345              		.loc 1 193 0
 346 0014 4FF42043 		mov	r3, #40960
 347 0018 C4F20603 		movt	r3, 16390
 348 001c 7A68     		ldr	r2, [r7, #4]
 349 001e D268     		ldr	r2, [r2, #12]
 350 0020 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 351 0022 D971     		strb	r1, [r3, #7]
 352 0024 02F10102 		add	r2, r2, #1
 353 0028 7B68     		ldr	r3, [r7, #4]
 354 002a DA60     		str	r2, [r3, #12]
 194:../Generated_Code/IO1.c ****     DeviceDataPrv->OutSentDataNum++;   /* Increment the counter of sent characters. */
 355              		.loc 1 194 0
 356 002c 7B68     		ldr	r3, [r7, #4]
 357 002e 5B89     		ldrh	r3, [r3, #10]
 358 0030 03F10103 		add	r3, r3, #1
 359 0034 9AB2     		uxth	r2, r3
 360 0036 7B68     		ldr	r3, [r7, #4]
 361 0038 5A81     		strh	r2, [r3, #10]	@ movhi
 195:../Generated_Code/IO1.c ****     if (DeviceDataPrv->OutSentDataNum == DeviceDataPrv->OutDataNumReq) {
 362              		.loc 1 195 0
 363 003a 7B68     		ldr	r3, [r7, #4]
 364 003c 5A89     		ldrh	r2, [r3, #10]
 365 003e 7B68     		ldr	r3, [r7, #4]
 366 0040 1B8A     		ldrh	r3, [r3, #16]
 367 0042 9A42     		cmp	r2, r3
 368 0044 0BD1     		bne	.L4
 196:../Generated_Code/IO1.c ****       DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of characters to be send by SendBl
 369              		.loc 1 196 0
 370 0046 7B68     		ldr	r3, [r7, #4]
 371 0048 4FF00002 		mov	r2, #0
 372 004c 1A82     		strh	r2, [r3, #16]	@ movhi
 373 004e 06E0     		b	.L4
 374              	.L5:
 197:../Generated_Code/IO1.c ****     }
 198:../Generated_Code/IO1.c ****   } else {
 199:../Generated_Code/IO1.c ****     DeviceDataPrv->SerFlag &= (uint16_t)(~(uint16_t)ENABLED_TX_INT); /* Clear the flag ENABLED_TX_I
 375              		.loc 1 199 0
 376 0050 7B68     		ldr	r3, [r7, #4]
 377 0052 1B88     		ldrh	r3, [r3, #0]
 378 0054 23F00103 		bic	r3, r3, #1
 379 0058 9AB2     		uxth	r2, r3
 380 005a 7B68     		ldr	r3, [r7, #4]
 381 005c 1A80     		strh	r2, [r3, #0]	@ movhi
 382              	.L4:
 200:../Generated_Code/IO1.c ****   }
 201:../Generated_Code/IO1.c **** }
 383              		.loc 1 201 0
 384 005e 07F10C07 		add	r7, r7, #12
 385 0062 BD46     		mov	sp, r7
 386 0064 80BC     		pop	{r7}
 387 0066 7047     		bx	lr
 388              		.cfi_endproc
 389              	.LFE2:
 391              		.section	.text.IO1_Main,"ax",%progbits
 392              		.align	2
 393              		.global	IO1_Main
 394              		.thumb
 395              		.thumb_func
 397              	IO1_Main:
 398              	.LFB3:
 202:../Generated_Code/IO1.c **** 
 203:../Generated_Code/IO1.c **** /*
 204:../Generated_Code/IO1.c **** ** ===================================================================
 205:../Generated_Code/IO1.c **** **     Method      :  IO1_Main (component Serial_LDD)
 206:../Generated_Code/IO1.c **** **
 207:../Generated_Code/IO1.c **** **     Description :
 208:../Generated_Code/IO1.c **** **         This method is available only in the polling mode (Interrupt
 209:../Generated_Code/IO1.c **** **         service/event = 'no'). If interrupt service is disabled this
 210:../Generated_Code/IO1.c **** **         method replaces the interrupt handler. This method should be
 211:../Generated_Code/IO1.c **** **         called if Receive/SendBlock was invoked before in order to
 212:../Generated_Code/IO1.c **** **         run the reception/transmission. The end of the
 213:../Generated_Code/IO1.c **** **         receiving/transmitting is indicated by OnBlockSent or
 214:../Generated_Code/IO1.c **** **         OnBlockReceived event. 
 215:../Generated_Code/IO1.c **** **     Parameters  :
 216:../Generated_Code/IO1.c **** **         NAME            - DESCRIPTION
 217:../Generated_Code/IO1.c **** **       * DeviceDataPtr   - Device data structure
 218:../Generated_Code/IO1.c **** **                           pointer returned by <Init> method.
 219:../Generated_Code/IO1.c **** **     Returns     : Nothing
 220:../Generated_Code/IO1.c **** ** ===================================================================
 221:../Generated_Code/IO1.c **** */
 222:../Generated_Code/IO1.c **** void IO1_Main(LDD_TDeviceData *DeviceDataPtr)
 223:../Generated_Code/IO1.c **** {
 399              		.loc 1 223 0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 16
 402              		@ frame_needed = 1, uses_anonymous_args = 0
 403 0000 90B5     		push	{r4, r7, lr}
 404              	.LCFI9:
 405              		.cfi_def_cfa_offset 12
 406              		.cfi_offset 14, -4
 407              		.cfi_offset 7, -8
 408              		.cfi_offset 4, -12
 409 0002 85B0     		sub	sp, sp, #20
 410              	.LCFI10:
 411              		.cfi_def_cfa_offset 32
 412 0004 00AF     		add	r7, sp, #0
 413              	.LCFI11:
 414              		.cfi_def_cfa_register 7
 415 0006 7860     		str	r0, [r7, #4]
 224:../Generated_Code/IO1.c ****   IO1_TDeviceDataPtr DeviceDataPrv = (IO1_TDeviceDataPtr)DeviceDataPtr;
 416              		.loc 1 224 0
 417 0008 7B68     		ldr	r3, [r7, #4]
 418 000a FB60     		str	r3, [r7, #12]
 225:../Generated_Code/IO1.c ****   register uint16_t StatReg = UART_PDD_ReadInterruptStatusReg(UART0_BASE_PTR); /* Read status regis
 419              		.loc 1 225 0
 420 000c 4FF42043 		mov	r3, #40960
 421 0010 C4F20603 		movt	r3, 16390
 422 0014 1B79     		ldrb	r3, [r3, #4]
 423 0016 DBB2     		uxtb	r3, r3
 424 0018 1C46     		mov	r4, r3
 226:../Generated_Code/IO1.c **** 
 227:../Generated_Code/IO1.c ****   if (StatReg & (UART_S1_NF_MASK | UART_S1_OR_MASK | UART_S1_FE_MASK | UART_S1_PF_MASK)) { /* Is an
 425              		.loc 1 227 0
 426 001a 2346     		mov	r3, r4
 427 001c 03F00F03 		and	r3, r3, #15
 428 0020 002B     		cmp	r3, #0
 429 0022 07D0     		beq	.L8
 228:../Generated_Code/IO1.c ****     (void)UART_PDD_GetChar8(UART0_BASE_PTR); /* Dummy read 8-bit character from receiver */
 430              		.loc 1 228 0
 431 0024 4FF42043 		mov	r3, #40960
 432 0028 C4F20603 		movt	r3, 16390
 433 002c DB79     		ldrb	r3, [r3, #7]
 229:../Generated_Code/IO1.c ****     StatReg &= (uint16_t)(~(uint16_t)UART_S1_RDRF_MASK); /* Clear the receive data flag to discard 
 434              		.loc 1 229 0
 435 002e 24F02003 		bic	r3, r4, #32
 436 0032 9CB2     		uxth	r4, r3
 437              	.L8:
 230:../Generated_Code/IO1.c ****   }
 231:../Generated_Code/IO1.c ****   if (StatReg & UART_S1_RDRF_MASK) {   /* Is the receiver's interrupt flag set? */
 438              		.loc 1 231 0
 439 0034 2346     		mov	r3, r4
 440 0036 03F02003 		and	r3, r3, #32
 441 003a 002B     		cmp	r3, #0
 442 003c 02D0     		beq	.L9
 232:../Generated_Code/IO1.c ****     InterruptRx(DeviceDataPrv);        /* If yes, then invoke the internal service routine. This ro
 443              		.loc 1 232 0
 444 003e F868     		ldr	r0, [r7, #12]
 445 0040 FFF7FEFF 		bl	InterruptRx
 446              	.L9:
 233:../Generated_Code/IO1.c ****   }
 234:../Generated_Code/IO1.c ****   if (DeviceDataPrv->SerFlag & ENABLED_TX_INT) { /* Is the transmitter interrupt enabled? */
 447              		.loc 1 234 0
 448 0044 FB68     		ldr	r3, [r7, #12]
 449 0046 1B88     		ldrh	r3, [r3, #0]
 450 0048 03F00103 		and	r3, r3, #1
 451 004c DBB2     		uxtb	r3, r3
 452 004e 002B     		cmp	r3, #0
 453 0050 07D0     		beq	.L7
 235:../Generated_Code/IO1.c ****     if (StatReg & UART_S1_TDRE_MASK) { /* Is the transmitter empty? */
 454              		.loc 1 235 0
 455 0052 2346     		mov	r3, r4
 456 0054 03F08003 		and	r3, r3, #128
 457 0058 002B     		cmp	r3, #0
 458 005a 02D0     		beq	.L7
 236:../Generated_Code/IO1.c ****       InterruptTx(DeviceDataPrv);      /* If yes, then invoke the internal service routine. This ro
 459              		.loc 1 236 0
 460 005c F868     		ldr	r0, [r7, #12]
 461 005e FFF7FEFF 		bl	InterruptTx
 462              	.L7:
 237:../Generated_Code/IO1.c ****     }
 238:../Generated_Code/IO1.c ****   }
 239:../Generated_Code/IO1.c **** }
 463              		.loc 1 239 0
 464 0062 07F11407 		add	r7, r7, #20
 465 0066 BD46     		mov	sp, r7
 466 0068 90BD     		pop	{r4, r7, pc}
 467              		.cfi_endproc
 468              	.LFE3:
 470 006a 00BF     		.text
 471              	.Letext0:
 472              		.file 2 "C:/Freescale/CW MCU v10.3_121211/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 473              		.file 3 "../Generated_Code/PE_LDD.h"
 474              		.file 4 "../Generated_Code/IO_Map.h"
 475              		.file 5 "../Generated_Code/IO1.h"
DEFINED SYMBOLS
                            *ABS*:00000000 IO1.c
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:19     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:22     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:25     .text.IO1_Init:00000000 $t
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:30     .text.IO1_Init:00000000 IO1_Init
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:246    .text.InterruptRx:00000000 $t
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:250    .text.InterruptRx:00000000 InterruptRx
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:316    .text.InterruptTx:00000000 $t
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:320    .text.InterruptTx:00000000 InterruptTx
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:392    .text.IO1_Main:00000000 $t
C:\Users\z\AppData\Local\Temp\ccgtmuSa.s:397    .text.IO1_Main:00000000 IO1_Main
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
