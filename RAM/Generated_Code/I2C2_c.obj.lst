   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"I2C2.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  19              		.align	2
  22              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  23 0000 00000000 		.space	24
  23      00000000 
  23      00000000 
  23      00000000 
  23      00000000 
  24              		.section	.bss.INT_I2C1__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  25              		.align	2
  28              	INT_I2C1__DEFAULT_RTOS_ISRPARAM:
  29 0000 00000000 		.space	4
  30              		.section	.text.I2C2_Interrupt,"ax",%progbits
  31              		.align	2
  32              		.global	I2C2_Interrupt
  33              		.thumb
  34              		.thumb_func
  36              	I2C2_Interrupt:
  37              	.LFB0:
  38              		.file 1 "../Generated_Code/I2C2.c"
   1:../Generated_Code/I2C2.c **** /** ###################################################################
   2:../Generated_Code/I2C2.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/I2C2.c **** **     Filename    : I2C2.c
   4:../Generated_Code/I2C2.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/I2C2.c **** **     Processor   : MK40DX256ZVLQ10
   6:../Generated_Code/I2C2.c **** **     Component   : I2C_LDD
   7:../Generated_Code/I2C2.c **** **     Version     : Component 01.011, Driver 01.06, CPU db: 3.00.001
   8:../Generated_Code/I2C2.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/I2C2.c **** **     Date/Time   : 2013-04-11, 15:40, # CodeGen: 91
  10:../Generated_Code/I2C2.c **** **     Abstract    :
  11:../Generated_Code/I2C2.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/I2C2.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/I2C2.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/I2C2.c **** **          Interface features:
  15:../Generated_Code/I2C2.c **** **          MASTER mode
  16:../Generated_Code/I2C2.c **** **            - Multi master communication
  17:../Generated_Code/I2C2.c **** **            - The combined format of communication possible
  18:../Generated_Code/I2C2.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/I2C2.c **** **            - Acknowledge polling provided
  21:../Generated_Code/I2C2.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/I2C2.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/I2C2.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/I2C2.c **** **          SLAVE mode
  25:../Generated_Code/I2C2.c **** **            - 7-bit slave addressing
  26:../Generated_Code/I2C2.c **** **            - General call address detection provided
  27:../Generated_Code/I2C2.c **** **     Settings    :
  28:../Generated_Code/I2C2.c **** **          Component name                                 : I2C2
  29:../Generated_Code/I2C2.c **** **          I2C channel                                    : I2C1
  30:../Generated_Code/I2C2.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/I2C2.c **** **            Interrupt                                    : INT_I2C1
  32:../Generated_Code/I2C2.c **** **            Interrupt priority                           : 5
  33:../Generated_Code/I2C2.c **** **          Settings                                       : 
  34:../Generated_Code/I2C2.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/I2C2.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/I2C2.c **** **              Initialization                             : 
  37:../Generated_Code/I2C2.c **** **                Address mode                             : 7-bit addressing
  38:../Generated_Code/I2C2.c **** **                Target slave address init                : 1D
  39:../Generated_Code/I2C2.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/I2C2.c **** **            Pins                                         : 
  41:../Generated_Code/I2C2.c **** **              SDA pin                                    : 
  42:../Generated_Code/I2C2.c **** **                SDA pin                                  : PTE0/SPI1_PCS1/UART1_TX/SDHC0_D1/FB_AD
  43:../Generated_Code/I2C2.c **** **                SDA pin signal                           : 
  44:../Generated_Code/I2C2.c **** **              SCL pin                                    : 
  45:../Generated_Code/I2C2.c **** **                SCL pin                                  : PTE1/SPI1_SOUT/UART1_RX/SDHC0_D0/FB_AD
  46:../Generated_Code/I2C2.c **** **                SCL pin signal                           : 
  47:../Generated_Code/I2C2.c **** **              High drive select                          : Disabled
  48:../Generated_Code/I2C2.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/I2C2.c **** **            Internal frequency (multiplier factor)       : 24 MHz
  50:../Generated_Code/I2C2.c **** **            Bits 0-2 of Frequency divider register       : 001
  51:../Generated_Code/I2C2.c **** **            Bits 3-5 of Frequency divider register       : 011
  52:../Generated_Code/I2C2.c **** **            SCL frequency                                : 250 kHz
  53:../Generated_Code/I2C2.c **** **            SDA Hold                                     : 0.375 us
  54:../Generated_Code/I2C2.c **** **            SCL start Hold                               : 1.917 us
  55:../Generated_Code/I2C2.c **** **            SCL stop Hold                                : 2.042 us
  56:../Generated_Code/I2C2.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/I2C2.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/I2C2.c **** **          Initialization                                 : 
  59:../Generated_Code/I2C2.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/I2C2.c **** **            Auto initialization                          : yes
  61:../Generated_Code/I2C2.c **** **            Event mask                                   : 
  62:../Generated_Code/I2C2.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/I2C2.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/I2C2.c **** **              OnMasterByteReceived                       : Disabled
  65:../Generated_Code/I2C2.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/I2C2.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/I2C2.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/I2C2.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/I2C2.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/I2C2.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/I2C2.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/I2C2.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/I2C2.c **** **              OnError                                    : Enabled
  74:../Generated_Code/I2C2.c **** **          CPU clock/configuration selection              : 
  75:../Generated_Code/I2C2.c **** **            Clock configuration 0                        : This component enabled
  76:../Generated_Code/I2C2.c **** **            Clock configuration 1                        : This component disabled
  77:../Generated_Code/I2C2.c **** **            Clock configuration 2                        : This component disabled
  78:../Generated_Code/I2C2.c **** **            Clock configuration 3                        : This component disabled
  79:../Generated_Code/I2C2.c **** **            Clock configuration 4                        : This component disabled
  80:../Generated_Code/I2C2.c **** **            Clock configuration 5                        : This component disabled
  81:../Generated_Code/I2C2.c **** **            Clock configuration 6                        : This component disabled
  82:../Generated_Code/I2C2.c **** **            Clock configuration 7                        : This component disabled
  83:../Generated_Code/I2C2.c **** **     Contents    :
  84:../Generated_Code/I2C2.c **** **         Init               - LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr);
  85:../Generated_Code/I2C2.c **** **         Deinit             - void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr);
  86:../Generated_Code/I2C2.c **** **         MasterSendBlock    - LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD
  87:../Generated_Code/I2C2.c **** **         MasterReceiveBlock - LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, 
  88:../Generated_Code/I2C2.c **** **         SelectSlaveDevice  - LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr,..
  89:../Generated_Code/I2C2.c **** **         GetError           - LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TE
  90:../Generated_Code/I2C2.c **** **         CheckBus           - LDD_TError I2C2_CheckBus(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TB
  91:../Generated_Code/I2C2.c **** **
  92:../Generated_Code/I2C2.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  93:../Generated_Code/I2C2.c **** **     
  94:../Generated_Code/I2C2.c **** **     http      : www.freescale.com
  95:../Generated_Code/I2C2.c **** **     mail      : support@freescale.com
  96:../Generated_Code/I2C2.c **** ** ###################################################################*/
  97:../Generated_Code/I2C2.c **** 
  98:../Generated_Code/I2C2.c **** /* MODULE I2C2. */
  99:../Generated_Code/I2C2.c **** 
 100:../Generated_Code/I2C2.c **** #include "Events.h"
 101:../Generated_Code/I2C2.c **** #include "I2C2.h"
 102:../Generated_Code/I2C2.c **** #include "PORT_PDD.h"
 103:../Generated_Code/I2C2.c **** #include "I2C_PDD.h"
 104:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} No RTOS includes */
 105:../Generated_Code/I2C2.c **** #include "IO_Map.h"
 106:../Generated_Code/I2C2.c **** 
 107:../Generated_Code/I2C2.c **** 
 108:../Generated_Code/I2C2.c **** /* SerFlag bits */
 109:../Generated_Code/I2C2.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 110:../Generated_Code/I2C2.c **** #define ADDR_COMPLETE           0x02U  /* 10-bit address transmission complete   */
 111:../Generated_Code/I2C2.c **** #define REP_ADDR_COMPLETE       0x04U  /* repeated address transmission complete */
 112:../Generated_Code/I2C2.c **** #define GENERAL_CALL            0x08U  /* General call flag */
 113:../Generated_Code/I2C2.c **** #define ADDR_10                 0x10U  /* 10-bit addr flag */
 114:../Generated_Code/I2C2.c **** #define ADDR_7                  0x20U  /* 7-bit addr flag */
 115:../Generated_Code/I2C2.c **** 
 116:../Generated_Code/I2C2.c **** typedef struct {
 117:../Generated_Code/I2C2.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 118:../Generated_Code/I2C2.c ****                                        /* Bits: 0 - Running int from TX */
 119:../Generated_Code/I2C2.c ****                                        /*       1 - 10-bit address transmission complete   */
 120:../Generated_Code/I2C2.c ****                                        /*       2 - repeated address transmission complete */
 121:../Generated_Code/I2C2.c ****                                        /*       3 - General Call flag */
 122:../Generated_Code/I2C2.c ****                                        /*       4 - 10-bit addr flag */
 123:../Generated_Code/I2C2.c ****                                        /*       5 - 7-bit addr flag */
 124:../Generated_Code/I2C2.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 125:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask;        /* Variable for errors mask value */
 126:../Generated_Code/I2C2.c ****   uint8_t SlaveAddr;                   /* Variable for Slave address */
 127:../Generated_Code/I2C2.c ****   uint8_t SlaveAddrHigh;               /* Variable for High byte of the Slave address (10-bit addre
 128:../Generated_Code/I2C2.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 129:../Generated_Code/I2C2.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 130:../Generated_Code/I2C2.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 131:../Generated_Code/I2C2.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 132:../Generated_Code/I2C2.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 133:../Generated_Code/I2C2.c **** } I2C2_TDeviceData;
 134:../Generated_Code/I2C2.c **** 
 135:../Generated_Code/I2C2.c **** typedef I2C2_TDeviceData *I2C2_TDeviceDataPtr; /* Pointer to the device data structure. */
 136:../Generated_Code/I2C2.c **** 
 137:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 138:../Generated_Code/I2C2.c **** static I2C2_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 139:../Generated_Code/I2C2.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 140:../Generated_Code/I2C2.c **** static I2C2_TDeviceDataPtr INT_I2C1__DEFAULT_RTOS_ISRPARAM;
 141:../Generated_Code/I2C2.c **** 
 142:../Generated_Code/I2C2.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED | LD
 143:../Generated_Code/I2C2.c **** 
 144:../Generated_Code/I2C2.c **** /*
 145:../Generated_Code/I2C2.c **** ** ===================================================================
 146:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Interrupt (component I2C_LDD)
 147:../Generated_Code/I2C2.c **** **
 148:../Generated_Code/I2C2.c **** **     Description :
 149:../Generated_Code/I2C2.c **** **         The method services the interrupt of the selected peripheral(s)
 150:../Generated_Code/I2C2.c **** **         and eventually invokes event(s) of the component.
 151:../Generated_Code/I2C2.c **** **         This method is internal. It is used by Processor Expert only.
 152:../Generated_Code/I2C2.c **** ** ===================================================================
 153:../Generated_Code/I2C2.c **** */
 154:../Generated_Code/I2C2.c **** 
 155:../Generated_Code/I2C2.c **** PE_ISR(I2C2_Interrupt)
 156:../Generated_Code/I2C2.c **** {
  39              		.loc 1 156 0
  40              		.cfi_startproc
  41              		@ Stack Align: May be called with mis-aligned SP.
  42              		@ args = 0, pretend = 0, frame = 8
  43              		@ frame_needed = 1, uses_anonymous_args = 0
  44 0000 6846     		mov	r0, sp
  45              		.cfi_register 13, 0
  46 0002 20F00701 		bic	r1, r0, #7
  47 0006 8D46     		mov	sp, r1
  48 0008 91B5     		push	{r0, r4, r7, lr}
  49              	.LCFI0:
  50              		.cfi_def_cfa_offset 16
  51              		.cfi_offset 14, -4
  52              		.cfi_offset 7, -8
  53              		.cfi_offset 4, -12
  54              		.cfi_offset 13, -16
  55 000a 82B0     		sub	sp, sp, #8
  56              	.LCFI1:
  57              		.cfi_def_cfa_offset 24
  58 000c 00AF     		add	r7, sp, #0
  59              	.LCFI2:
  60              		.cfi_def_cfa_register 7
 157:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 158:../Generated_Code/I2C2.c ****   I2C2_TDeviceDataPtr DeviceDataPrv = INT_I2C1__DEFAULT_RTOS_ISRPARAM;
  61              		.loc 1 158 0
  62 000e 40F20003 		movw	r3, #:lower16:INT_I2C1__DEFAULT_RTOS_ISRPARAM
  63 0012 C0F20003 		movt	r3, #:upper16:INT_I2C1__DEFAULT_RTOS_ISRPARAM
  64 0016 1B68     		ldr	r3, [r3, #0]
  65 0018 3B60     		str	r3, [r7, #0]
 159:../Generated_Code/I2C2.c ****   LDD_I2C_TErrorMask ErrorMask = 0x00U; /* Temporary variable for error mask */
  66              		.loc 1 159 0
  67 001a 4FF00003 		mov	r3, #0
  68 001e FB80     		strh	r3, [r7, #6]	@ movhi
 160:../Generated_Code/I2C2.c ****   register uint8_t Status;             /* Temporary variable for status register */
 161:../Generated_Code/I2C2.c **** 
 162:../Generated_Code/I2C2.c ****   Status = I2C_PDD_ReadStatusReg(I2C1_BASE_PTR); /* Safe status register */
  69              		.loc 1 162 0
  70 0020 4FF4E043 		mov	r3, #28672
  71 0024 C4F20603 		movt	r3, 16390
  72 0028 DB78     		ldrb	r3, [r3, #3]
  73 002a DCB2     		uxtb	r4, r3
 163:../Generated_Code/I2C2.c ****   I2C_PDD_ClearInterruptFlags(I2C1_BASE_PTR, (Status)); /* Clear interrupt flag */
  74              		.loc 1 163 0
  75 002c 4FF4E043 		mov	r3, #28672
  76 0030 C4F20603 		movt	r3, 16390
  77 0034 4FF4E042 		mov	r2, #28672
  78 0038 C4F20602 		movt	r2, 16390
  79 003c D278     		ldrb	r2, [r2, #3]
  80 003e D2B2     		uxtb	r2, r2
  81 0040 D2B2     		uxtb	r2, r2
  82 0042 22F01202 		bic	r2, r2, #18
  83 0046 D1B2     		uxtb	r1, r2
  84 0048 E2B2     		uxtb	r2, r4
  85 004a 0A43     		orrs	r2, r2, r1
  86 004c D2B2     		uxtb	r2, r2
  87 004e D2B2     		uxtb	r2, r2
  88 0050 DA70     		strb	r2, [r3, #3]
 164:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
  89              		.loc 1 164 0
  90 0052 4FF4E043 		mov	r3, #28672
  91 0056 C4F20603 		movt	r3, 16390
  92 005a 9B78     		ldrb	r3, [r3, #2]
  93 005c DBB2     		uxtb	r3, r3
  94 005e 03F02003 		and	r3, r3, #32
  95 0062 002B     		cmp	r3, #0
  96 0064 00F05A81 		beq	.L2
 165:../Generated_Code/I2C2.c ****     if (I2C_PDD_GetTransmitMode(I2C1_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
  97              		.loc 1 165 0
  98 0068 4FF4E043 		mov	r3, #28672
  99 006c C4F20603 		movt	r3, 16390
 100 0070 9B78     		ldrb	r3, [r3, #2]
 101 0072 DBB2     		uxtb	r3, r3
 102 0074 03F01003 		and	r3, r3, #16
 103 0078 002B     		cmp	r3, #0
 104 007a 00F0F780 		beq	.L3
 166:../Generated_Code/I2C2.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
 105              		.loc 1 166 0
 106 007e 2346     		mov	r3, r4
 107 0080 03F00103 		and	r3, r3, #1
 108 0084 DBB2     		uxtb	r3, r3
 109 0086 002B     		cmp	r3, #0
 110 0088 36D0     		beq	.L4
 167:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
 111              		.loc 1 167 0
 112 008a 4FF4E043 		mov	r3, #28672
 113 008e C4F20603 		movt	r3, 16390
 114 0092 4FF4E042 		mov	r2, #28672
 115 0096 C4F20602 		movt	r2, 16390
 116 009a 9278     		ldrb	r2, [r2, #2]
 117 009c D2B2     		uxtb	r2, r2
 118 009e 22F02002 		bic	r2, r2, #32
 119 00a2 D2B2     		uxtb	r2, r2
 120 00a4 9A70     		strb	r2, [r3, #2]
 168:../Generated_Code/I2C2.c ****         I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 121              		.loc 1 168 0
 122 00a6 4FF4E043 		mov	r3, #28672
 123 00aa C4F20603 		movt	r3, 16390
 124 00ae 4FF4E042 		mov	r2, #28672
 125 00b2 C4F20602 		movt	r2, 16390
 126 00b6 9278     		ldrb	r2, [r2, #2]
 127 00b8 D2B2     		uxtb	r2, r2
 128 00ba 22F01002 		bic	r2, r2, #16
 129 00be D2B2     		uxtb	r2, r2
 130 00c0 9A70     		strb	r2, [r3, #2]
 169:../Generated_Code/I2C2.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 131              		.loc 1 169 0
 132 00c2 3B68     		ldr	r3, [r7, #0]
 133 00c4 4FF00002 		mov	r2, #0
 134 00c8 9A81     		strh	r2, [r3, #12]	@ movhi
 170:../Generated_Code/I2C2.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 135              		.loc 1 170 0
 136 00ca 3B68     		ldr	r3, [r7, #0]
 137 00cc 4FF00002 		mov	r2, #0
 138 00d0 DA80     		strh	r2, [r3, #6]	@ movhi
 171:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 139              		.loc 1 171 0
 140 00d2 3B68     		ldr	r3, [r7, #0]
 141 00d4 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 142 00d6 23F00103 		bic	r3, r3, #1
 143 00da DAB2     		uxtb	r2, r3
 144 00dc 3B68     		ldr	r3, [r7, #0]
 145 00de 1A70     		strb	r2, [r3, #0]
 172:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Set the flag */
 146              		.loc 1 172 0
 147 00e0 3B68     		ldr	r3, [r7, #0]
 148 00e2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 149 00e4 43F00603 		orr	r3, r3, #6
 150 00e8 DAB2     		uxtb	r2, r3
 151 00ea 3B68     		ldr	r3, [r7, #0]
 152 00ec 1A70     		strb	r2, [r3, #0]
 173:../Generated_Code/I2C2.c ****         ErrorMask |= LDD_I2C_MASTER_NACK; /* Set the Master Nack error mask */
 153              		.loc 1 173 0
 154 00ee FB88     		ldrh	r3, [r7, #6]	@ movhi
 155 00f0 43F00803 		orr	r3, r3, #8
 156 00f4 FB80     		strh	r3, [r7, #6]	@ movhi
 157 00f6 3BE1     		b	.L5
 158              	.L4:
 174:../Generated_Code/I2C2.c ****       } else {
 175:../Generated_Code/I2C2.c ****         if ((DeviceDataPrv->SerFlag & ADDR_COMPLETE) != 0x00U) { /* If 10-bit addr has been complet
 159              		.loc 1 175 0
 160 00f8 3B68     		ldr	r3, [r7, #0]
 161 00fa 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 162 00fc 03F00203 		and	r3, r3, #2
 163 0100 002B     		cmp	r3, #0
 164 0102 00F0A480 		beq	.L6
 176:../Generated_Code/I2C2.c ****           if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 165              		.loc 1 176 0
 166 0106 3B68     		ldr	r3, [r7, #0]
 167 0108 9B89     		ldrh	r3, [r3, #12]
 168 010a 002B     		cmp	r3, #0
 169 010c 13D0     		beq	.L7
 177:../Generated_Code/I2C2.c ****             DeviceDataPrv->OutLenM--;  /* Decrease number of chars for the transmit */
 170              		.loc 1 177 0
 171 010e 3B68     		ldr	r3, [r7, #0]
 172 0110 9B89     		ldrh	r3, [r3, #12]
 173 0112 03F1FF33 		add	r3, r3, #-1
 174 0116 9AB2     		uxth	r2, r3
 175 0118 3B68     		ldr	r3, [r7, #0]
 176 011a 9A81     		strh	r2, [r3, #12]	@ movhi
 178:../Generated_Code/I2C2.c ****             I2C_PDD_WriteDataReg(I2C1_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 177              		.loc 1 178 0
 178 011c 4FF4E043 		mov	r3, #28672
 179 0120 C4F20603 		movt	r3, 16390
 180 0124 3A68     		ldr	r2, [r7, #0]
 181 0126 1269     		ldr	r2, [r2, #16]
 182 0128 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 183 012a 1971     		strb	r1, [r3, #4]
 184 012c 02F10102 		add	r2, r2, #1
 185 0130 3B68     		ldr	r3, [r7, #0]
 186 0132 1A61     		str	r2, [r3, #16]
 187 0134 1CE1     		b	.L5
 188              	.L7:
 179:../Generated_Code/I2C2.c ****           }
 180:../Generated_Code/I2C2.c ****           else {
 181:../Generated_Code/I2C2.c ****             if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 189              		.loc 1 181 0
 190 0136 3B68     		ldr	r3, [r7, #0]
 191 0138 DB88     		ldrh	r3, [r3, #6]
 192 013a 002B     		cmp	r3, #0
 193 013c 5AD0     		beq	.L8
 182:../Generated_Code/I2C2.c ****               if ((DeviceDataPrv->SerFlag & REP_ADDR_COMPLETE) != 0x00U) { /* If repeated start and
 194              		.loc 1 182 0
 195 013e 3B68     		ldr	r3, [r7, #0]
 196 0140 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 197 0142 03F00403 		and	r3, r3, #4
 198 0146 002B     		cmp	r3, #0
 199 0148 34D0     		beq	.L9
 183:../Generated_Code/I2C2.c ****                 if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 200              		.loc 1 183 0
 201 014a 3B68     		ldr	r3, [r7, #0]
 202 014c DB88     		ldrh	r3, [r3, #6]
 203 014e 012B     		cmp	r3, #1
 204 0150 0ED1     		bne	.L10
 184:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_DISABLE); /* then transmit A
 205              		.loc 1 184 0
 206 0152 4FF4E043 		mov	r3, #28672
 207 0156 C4F20603 		movt	r3, 16390
 208 015a 4FF4E042 		mov	r2, #28672
 209 015e C4F20602 		movt	r2, 16390
 210 0162 9278     		ldrb	r2, [r2, #2]
 211 0164 D2B2     		uxtb	r2, r2
 212 0166 42F00802 		orr	r2, r2, #8
 213 016a D2B2     		uxtb	r2, r2
 214 016c 9A70     		strb	r2, [r3, #2]
 215 016e 0DE0     		b	.L11
 216              	.L10:
 185:../Generated_Code/I2C2.c ****                 } else {
 186:../Generated_Code/I2C2.c ****                   I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_ENABLE); /* else transmit AC
 217              		.loc 1 186 0
 218 0170 4FF4E043 		mov	r3, #28672
 219 0174 C4F20603 		movt	r3, 16390
 220 0178 4FF4E042 		mov	r2, #28672
 221 017c C4F20602 		movt	r2, 16390
 222 0180 9278     		ldrb	r2, [r2, #2]
 223 0182 D2B2     		uxtb	r2, r2
 224 0184 22F00802 		bic	r2, r2, #8
 225 0188 D2B2     		uxtb	r2, r2
 226 018a 9A70     		strb	r2, [r3, #2]
 227              	.L11:
 187:../Generated_Code/I2C2.c ****                 }
 188:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 228              		.loc 1 188 0
 229 018c 4FF4E043 		mov	r3, #28672
 230 0190 C4F20603 		movt	r3, 16390
 231 0194 4FF4E042 		mov	r2, #28672
 232 0198 C4F20602 		movt	r2, 16390
 233 019c 9278     		ldrb	r2, [r2, #2]
 234 019e D2B2     		uxtb	r2, r2
 235 01a0 22F01002 		bic	r2, r2, #16
 236 01a4 D2B2     		uxtb	r2, r2
 237 01a6 9A70     		strb	r2, [r3, #2]
 189:../Generated_Code/I2C2.c ****                 (void)I2C_PDD_ReadDataReg(I2C1_BASE_PTR); /* Dummy read character */
 238              		.loc 1 189 0
 239 01a8 4FF4E043 		mov	r3, #28672
 240 01ac C4F20603 		movt	r3, 16390
 241 01b0 1B79     		ldrb	r3, [r3, #4]
 242 01b2 DDE0     		b	.L5
 243              	.L9:
 190:../Generated_Code/I2C2.c ****               } else {                 /* Repeated address has not been completed for 10-bit addres
 191:../Generated_Code/I2C2.c ****                 I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* Repeat start cycle generated */
 244              		.loc 1 191 0
 245 01b4 4FF4E043 		mov	r3, #28672
 246 01b8 C4F20603 		movt	r3, 16390
 247 01bc 4FF4E042 		mov	r2, #28672
 248 01c0 C4F20602 		movt	r2, 16390
 249 01c4 9278     		ldrb	r2, [r2, #2]
 250 01c6 D2B2     		uxtb	r2, r2
 251 01c8 42F00402 		orr	r2, r2, #4
 252 01cc D2B2     		uxtb	r2, r2
 253 01ce 9A70     		strb	r2, [r3, #2]
 192:../Generated_Code/I2C2.c ****                 I2C_PDD_WriteDataReg(I2C1_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddrHigh | 0x01U)
 254              		.loc 1 192 0
 255 01d0 4FF4E043 		mov	r3, #28672
 256 01d4 C4F20603 		movt	r3, 16390
 257 01d8 3A68     		ldr	r2, [r7, #0]
 258 01da 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 259 01dc 42F00102 		orr	r2, r2, #1
 260 01e0 D2B2     		uxtb	r2, r2
 261 01e2 1A71     		strb	r2, [r3, #4]
 193:../Generated_Code/I2C2.c ****                 DeviceDataPrv->SerFlag |= REP_ADDR_COMPLETE;
 262              		.loc 1 193 0
 263 01e4 3B68     		ldr	r3, [r7, #0]
 264 01e6 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 265 01e8 43F00403 		orr	r3, r3, #4
 266 01ec DAB2     		uxtb	r2, r3
 267 01ee 3B68     		ldr	r3, [r7, #0]
 268 01f0 1A70     		strb	r2, [r3, #0]
 269 01f2 BDE0     		b	.L5
 270              	.L8:
 194:../Generated_Code/I2C2.c ****               }
 195:../Generated_Code/I2C2.c ****             }
 196:../Generated_Code/I2C2.c ****             else {
 197:../Generated_Code/I2C2.c ****               DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 271              		.loc 1 197 0
 272 01f4 3B68     		ldr	r3, [r7, #0]
 273 01f6 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 274 01f8 23F00103 		bic	r3, r3, #1
 275 01fc DAB2     		uxtb	r2, r3
 276 01fe 3B68     		ldr	r3, [r7, #0]
 277 0200 1A70     		strb	r2, [r3, #0]
 198:../Generated_Code/I2C2.c ****               if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 278              		.loc 1 198 0
 279 0202 3B68     		ldr	r3, [r7, #0]
 280 0204 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 281 0206 012B     		cmp	r3, #1
 282 0208 1BD1     		bne	.L12
 199:../Generated_Code/I2C2.c ****                 I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave
 283              		.loc 1 199 0
 284 020a 4FF4E043 		mov	r3, #28672
 285 020e C4F20603 		movt	r3, 16390
 286 0212 4FF4E042 		mov	r2, #28672
 287 0216 C4F20602 		movt	r2, 16390
 288 021a 9278     		ldrb	r2, [r2, #2]
 289 021c D2B2     		uxtb	r2, r2
 290 021e 22F02002 		bic	r2, r2, #32
 291 0222 D2B2     		uxtb	r2, r2
 292 0224 9A70     		strb	r2, [r3, #2]
 200:../Generated_Code/I2C2.c ****                 I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode 
 293              		.loc 1 200 0
 294 0226 4FF4E043 		mov	r3, #28672
 295 022a C4F20603 		movt	r3, 16390
 296 022e 4FF4E042 		mov	r2, #28672
 297 0232 C4F20602 		movt	r2, 16390
 298 0236 9278     		ldrb	r2, [r2, #2]
 299 0238 D2B2     		uxtb	r2, r2
 300 023a 22F01002 		bic	r2, r2, #16
 301 023e D2B2     		uxtb	r2, r2
 302 0240 9A70     		strb	r2, [r3, #2]
 303              	.L12:
 201:../Generated_Code/I2C2.c ****               }
 202:../Generated_Code/I2C2.c ****               I2C2_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event */
 304              		.loc 1 202 0
 305 0242 3B68     		ldr	r3, [r7, #0]
 306 0244 5B69     		ldr	r3, [r3, #20]
 307 0246 1846     		mov	r0, r3
 308 0248 FFF7FEFF 		bl	I2C2_OnMasterBlockSent
 309 024c 90E0     		b	.L5
 310              	.L6:
 203:../Generated_Code/I2C2.c ****             }
 204:../Generated_Code/I2C2.c ****           }
 205:../Generated_Code/I2C2.c ****         } else {
 206:../Generated_Code/I2C2.c ****           I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send second part of the
 311              		.loc 1 206 0
 312 024e 4FF4E043 		mov	r3, #28672
 313 0252 C4F20603 		movt	r3, 16390
 314 0256 3A68     		ldr	r2, [r7, #0]
 315 0258 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 316 025a 1A71     		strb	r2, [r3, #4]
 207:../Generated_Code/I2C2.c ****           DeviceDataPrv->SerFlag |= (ADDR_COMPLETE); /* Address complete */
 317              		.loc 1 207 0
 318 025c 3B68     		ldr	r3, [r7, #0]
 319 025e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 320 0260 43F00203 		orr	r3, r3, #2
 321 0264 DAB2     		uxtb	r2, r3
 322 0266 3B68     		ldr	r3, [r7, #0]
 323 0268 1A70     		strb	r2, [r3, #0]
 324 026a 81E0     		b	.L5
 325              	.L3:
 208:../Generated_Code/I2C2.c ****         }
 209:../Generated_Code/I2C2.c ****       }
 210:../Generated_Code/I2C2.c ****     }
 211:../Generated_Code/I2C2.c ****     else {
 212:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 326              		.loc 1 212 0
 327 026c 3B68     		ldr	r3, [r7, #0]
 328 026e DB88     		ldrh	r3, [r3, #6]
 329 0270 03F1FF33 		add	r3, r3, #-1
 330 0274 9AB2     		uxth	r2, r3
 331 0276 3B68     		ldr	r3, [r7, #0]
 332 0278 DA80     		strh	r2, [r3, #6]	@ movhi
 213:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 333              		.loc 1 213 0
 334 027a 3B68     		ldr	r3, [r7, #0]
 335 027c DB88     		ldrh	r3, [r3, #6]
 336 027e 002B     		cmp	r3, #0
 337 0280 12D0     		beq	.L13
 214:../Generated_Code/I2C2.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 338              		.loc 1 214 0
 339 0282 3B68     		ldr	r3, [r7, #0]
 340 0284 DB88     		ldrh	r3, [r3, #6]
 341 0286 012B     		cmp	r3, #1
 342 0288 31D1     		bne	.L14
 215:../Generated_Code/I2C2.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 343              		.loc 1 215 0
 344 028a 4FF4E043 		mov	r3, #28672
 345 028e C4F20603 		movt	r3, 16390
 346 0292 4FF4E042 		mov	r2, #28672
 347 0296 C4F20602 		movt	r2, 16390
 348 029a 9278     		ldrb	r2, [r2, #2]
 349 029c D2B2     		uxtb	r2, r2
 350 029e 42F00802 		orr	r2, r2, #8
 351 02a2 D2B2     		uxtb	r2, r2
 352 02a4 9A70     		strb	r2, [r3, #2]
 353 02a6 22E0     		b	.L14
 354              	.L13:
 216:../Generated_Code/I2C2.c ****         }
 217:../Generated_Code/I2C2.c ****       } else {
 218:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 355              		.loc 1 218 0
 356 02a8 3B68     		ldr	r3, [r7, #0]
 357 02aa 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 358 02ac 23F00103 		bic	r3, r3, #1
 359 02b0 DAB2     		uxtb	r2, r3
 360 02b2 3B68     		ldr	r3, [r7, #0]
 361 02b4 1A70     		strb	r2, [r3, #0]
 219:../Generated_Code/I2C2.c ****         I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 362              		.loc 1 219 0
 363 02b6 4FF4E043 		mov	r3, #28672
 364 02ba C4F20603 		movt	r3, 16390
 365 02be 4FF4E042 		mov	r2, #28672
 366 02c2 C4F20602 		movt	r2, 16390
 367 02c6 9278     		ldrb	r2, [r2, #2]
 368 02c8 D2B2     		uxtb	r2, r2
 369 02ca 22F02002 		bic	r2, r2, #32
 370 02ce D2B2     		uxtb	r2, r2
 371 02d0 9A70     		strb	r2, [r3, #2]
 220:../Generated_Code/I2C2.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 372              		.loc 1 220 0
 373 02d2 4FF4E043 		mov	r3, #28672
 374 02d6 C4F20603 		movt	r3, 16390
 375 02da 4FF4E042 		mov	r2, #28672
 376 02de C4F20602 		movt	r2, 16390
 377 02e2 9278     		ldrb	r2, [r2, #2]
 378 02e4 D2B2     		uxtb	r2, r2
 379 02e6 22F00802 		bic	r2, r2, #8
 380 02ea D2B2     		uxtb	r2, r2
 381 02ec 9A70     		strb	r2, [r3, #2]
 382              	.L14:
 221:../Generated_Code/I2C2.c ****       }
 222:../Generated_Code/I2C2.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C1_BASE_PTR); /* Receive character */
 383              		.loc 1 222 0
 384 02ee 3B68     		ldr	r3, [r7, #0]
 385 02f0 9A68     		ldr	r2, [r3, #8]
 386 02f2 4FF4E043 		mov	r3, #28672
 387 02f6 C4F20603 		movt	r3, 16390
 388 02fa 1B79     		ldrb	r3, [r3, #4]
 389 02fc DBB2     		uxtb	r3, r3
 390 02fe 1370     		strb	r3, [r2, #0]
 391 0300 02F10102 		add	r2, r2, #1
 392 0304 3B68     		ldr	r3, [r7, #0]
 393 0306 9A60     		str	r2, [r3, #8]
 223:../Generated_Code/I2C2.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 394              		.loc 1 223 0
 395 0308 3B68     		ldr	r3, [r7, #0]
 396 030a DB88     		ldrh	r3, [r3, #6]
 397 030c 002B     		cmp	r3, #0
 398 030e 2FD1     		bne	.L5
 224:../Generated_Code/I2C2.c ****         I2C2_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived event 
 399              		.loc 1 224 0
 400 0310 3B68     		ldr	r3, [r7, #0]
 401 0312 5B69     		ldr	r3, [r3, #20]
 402 0314 1846     		mov	r0, r3
 403 0316 FFF7FEFF 		bl	I2C2_OnMasterBlockReceived
 404 031a 29E0     		b	.L5
 405              	.L2:
 225:../Generated_Code/I2C2.c ****       }
 226:../Generated_Code/I2C2.c ****     }
 227:../Generated_Code/I2C2.c ****   } else {
 228:../Generated_Code/I2C2.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 406              		.loc 1 228 0
 407 031c 2346     		mov	r3, r4
 408 031e 03F01003 		and	r3, r3, #16
 409 0322 002B     		cmp	r3, #0
 410 0324 24D0     		beq	.L5
 229:../Generated_Code/I2C2.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 411              		.loc 1 229 0
 412 0326 3B68     		ldr	r3, [r7, #0]
 413 0328 4FF00002 		mov	r2, #0
 414 032c 9A81     		strh	r2, [r3, #12]	@ movhi
 230:../Generated_Code/I2C2.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 415              		.loc 1 230 0
 416 032e 3B68     		ldr	r3, [r7, #0]
 417 0330 4FF00002 		mov	r2, #0
 418 0334 DA80     		strh	r2, [r3, #6]	@ movhi
 231:../Generated_Code/I2C2.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 419              		.loc 1 231 0
 420 0336 3B68     		ldr	r3, [r7, #0]
 421 0338 4FF00102 		mov	r2, #1
 422 033c 5A70     		strb	r2, [r3, #1]
 232:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 423              		.loc 1 232 0
 424 033e 3B68     		ldr	r3, [r7, #0]
 425 0340 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 426 0342 23F00103 		bic	r3, r3, #1
 427 0346 DAB2     		uxtb	r2, r3
 428 0348 3B68     		ldr	r3, [r7, #0]
 429 034a 1A70     		strb	r2, [r3, #0]
 233:../Generated_Code/I2C2.c ****       I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 430              		.loc 1 233 0
 431 034c 4FF4E043 		mov	r3, #28672
 432 0350 C4F20603 		movt	r3, 16390
 433 0354 4FF4E042 		mov	r2, #28672
 434 0358 C4F20602 		movt	r2, 16390
 435 035c 9278     		ldrb	r2, [r2, #2]
 436 035e D2B2     		uxtb	r2, r2
 437 0360 22F01002 		bic	r2, r2, #16
 438 0364 D2B2     		uxtb	r2, r2
 439 0366 9A70     		strb	r2, [r3, #2]
 234:../Generated_Code/I2C2.c ****       ErrorMask |= LDD_I2C_ARBIT_LOST; /* Set the ArbitLost error mask */
 440              		.loc 1 234 0
 441 0368 FB88     		ldrh	r3, [r7, #6]	@ movhi
 442 036a 43F00403 		orr	r3, r3, #4
 443 036e FB80     		strh	r3, [r7, #6]	@ movhi
 444              	.L5:
 235:../Generated_Code/I2C2.c ****     }
 236:../Generated_Code/I2C2.c ****   }
 237:../Generated_Code/I2C2.c ****   if (ErrorMask != 0x00U) {            /* Is any error mask set? */
 445              		.loc 1 237 0
 446 0370 FB88     		ldrh	r3, [r7, #6]
 447 0372 002B     		cmp	r3, #0
 448 0374 0BD0     		beq	.L1
 238:../Generated_Code/I2C2.c ****     DeviceDataPrv->ErrorMask |= ErrorMask; /* Update list of error mask value */
 449              		.loc 1 238 0
 450 0376 3B68     		ldr	r3, [r7, #0]
 451 0378 5A88     		ldrh	r2, [r3, #2]
 452 037a FB88     		ldrh	r3, [r7, #6]	@ movhi
 453 037c 1343     		orrs	r3, r3, r2
 454 037e 9AB2     		uxth	r2, r3
 455 0380 3B68     		ldr	r3, [r7, #0]
 456 0382 5A80     		strh	r2, [r3, #2]	@ movhi
 239:../Generated_Code/I2C2.c ****     I2C2_OnError(DeviceDataPrv->UserData); /* If yes then invoke user event */
 457              		.loc 1 239 0
 458 0384 3B68     		ldr	r3, [r7, #0]
 459 0386 5B69     		ldr	r3, [r3, #20]
 460 0388 1846     		mov	r0, r3
 461 038a FFF7FEFF 		bl	I2C2_OnError
 462              	.L1:
 240:../Generated_Code/I2C2.c ****   }
 241:../Generated_Code/I2C2.c **** }
 463              		.loc 1 241 0
 464 038e 07F10807 		add	r7, r7, #8
 465 0392 BD46     		mov	sp, r7
 466 0394 BDE89140 		pop	{r0, r4, r7, lr}
 467 0398 8546     		mov	sp, r0
 468 039a 7047     		bx	lr
 469              		.cfi_endproc
 470              	.LFE0:
 472              		.section	.text.I2C2_Init,"ax",%progbits
 473              		.align	2
 474              		.global	I2C2_Init
 475              		.thumb
 476              		.thumb_func
 478              	I2C2_Init:
 479              	.LFB1:
 242:../Generated_Code/I2C2.c **** 
 243:../Generated_Code/I2C2.c **** /*
 244:../Generated_Code/I2C2.c **** ** ===================================================================
 245:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Init (component I2C_LDD)
 246:../Generated_Code/I2C2.c **** **
 247:../Generated_Code/I2C2.c **** **     Description :
 248:../Generated_Code/I2C2.c **** **         Initializes the device. Allocates memory for the device data
 249:../Generated_Code/I2C2.c **** **         structure, allocates interrupt vectors and sets interrupt
 250:../Generated_Code/I2C2.c **** **         priority, sets pin routing, sets timing, etc.
 251:../Generated_Code/I2C2.c **** **         If the "Enable in init. code" is set to "yes" value then the
 252:../Generated_Code/I2C2.c **** **         device is also enabled(see the description of the Enable()
 253:../Generated_Code/I2C2.c **** **         method). In this case the Enable() method is not necessary
 254:../Generated_Code/I2C2.c **** **         and needn't to be generated. 
 255:../Generated_Code/I2C2.c **** **         This method can be called only once. Before the second call
 256:../Generated_Code/I2C2.c **** **         of Init() the Deinit() must be called first.
 257:../Generated_Code/I2C2.c **** **     Parameters  :
 258:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 259:../Generated_Code/I2C2.c **** **       * UserDataPtr     - Pointer to the user or
 260:../Generated_Code/I2C2.c **** **                           RTOS specific data. This pointer will be
 261:../Generated_Code/I2C2.c **** **                           passed as an event or callback parameter.
 262:../Generated_Code/I2C2.c **** **     Returns     :
 263:../Generated_Code/I2C2.c **** **         ---             - Pointer to the device data structure. 
 264:../Generated_Code/I2C2.c **** ** ===================================================================
 265:../Generated_Code/I2C2.c **** */
 266:../Generated_Code/I2C2.c **** LDD_TDeviceData* I2C2_Init(LDD_TUserData *UserDataPtr)
 267:../Generated_Code/I2C2.c **** {
 480              		.loc 1 267 0
 481              		.cfi_startproc
 482              		@ args = 0, pretend = 0, frame = 16
 483              		@ frame_needed = 1, uses_anonymous_args = 0
 484              		@ link register save eliminated.
 485 0000 80B4     		push	{r7}
 486              	.LCFI3:
 487              		.cfi_def_cfa_offset 4
 488              		.cfi_offset 7, -4
 489 0002 85B0     		sub	sp, sp, #20
 490              	.LCFI4:
 491              		.cfi_def_cfa_offset 24
 492 0004 00AF     		add	r7, sp, #0
 493              	.LCFI5:
 494              		.cfi_def_cfa_register 7
 495 0006 7860     		str	r0, [r7, #4]
 268:../Generated_Code/I2C2.c ****   /* Allocate HAL device structure */
 269:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv;
 270:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 271:../Generated_Code/I2C2.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 496              		.loc 1 271 0
 497 0008 40F20003 		movw	r3, #:lower16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
 498 000c C0F20003 		movt	r3, #:upper16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
 499 0010 FB60     		str	r3, [r7, #12]
 272:../Generated_Code/I2C2.c **** 
 273:../Generated_Code/I2C2.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 500              		.loc 1 273 0
 501 0012 FB68     		ldr	r3, [r7, #12]
 502 0014 7A68     		ldr	r2, [r7, #4]
 503 0016 5A61     		str	r2, [r3, #20]
 274:../Generated_Code/I2C2.c **** 
 275:../Generated_Code/I2C2.c ****   /* Allocate interrupt vector */
 276:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 277:../Generated_Code/I2C2.c ****   INT_I2C1__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
 504              		.loc 1 277 0
 505 0018 40F20003 		movw	r3, #:lower16:INT_I2C1__DEFAULT_RTOS_ISRPARAM
 506 001c C0F20003 		movt	r3, #:upper16:INT_I2C1__DEFAULT_RTOS_ISRPARAM
 507 0020 FA68     		ldr	r2, [r7, #12]
 508 0022 1A60     		str	r2, [r3, #0]
 278:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag = ADDR_7;     /* Reset all flags start with 7-bit address mode */
 509              		.loc 1 278 0
 510 0024 FB68     		ldr	r3, [r7, #12]
 511 0026 4FF02002 		mov	r2, #32
 512 002a 1A70     		strb	r2, [r3, #0]
 279:../Generated_Code/I2C2.c ****   DeviceDataPrv->SlaveAddr = 0x3AU;    /* Set variable for slave address */
 513              		.loc 1 279 0
 514 002c FB68     		ldr	r3, [r7, #12]
 515 002e 4FF03A02 		mov	r2, #58
 516 0032 1A71     		strb	r2, [r3, #4]
 280:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 517              		.loc 1 280 0
 518 0034 FB68     		ldr	r3, [r7, #12]
 519 0036 4FF00102 		mov	r2, #1
 520 003a 5A70     		strb	r2, [r3, #1]
 281:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 521              		.loc 1 281 0
 522 003c FB68     		ldr	r3, [r7, #12]
 523 003e 4FF00002 		mov	r2, #0
 524 0042 DA80     		strh	r2, [r3, #6]	@ movhi
 282:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 525              		.loc 1 282 0
 526 0044 FB68     		ldr	r3, [r7, #12]
 527 0046 4FF00002 		mov	r2, #0
 528 004a 9A81     		strh	r2, [r3, #12]	@ movhi
 283:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;    /* Clear variable for errors mask value */
 529              		.loc 1 283 0
 530 004c FB68     		ldr	r3, [r7, #12]
 531 004e 4FF00002 		mov	r2, #0
 532 0052 5A80     		strh	r2, [r3, #2]	@ movhi
 284:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C1=1 */
 285:../Generated_Code/I2C2.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK;                                                   
 533              		.loc 1 285 0
 534 0054 4FF4E043 		mov	r3, #28672
 535 0058 C4F20403 		movt	r3, 16388
 536 005c 4FF4E042 		mov	r2, #28672
 537 0060 C4F20402 		movt	r2, 16388
 538 0064 02F58052 		add	r2, r2, #4096
 539 0068 02F13402 		add	r2, r2, #52
 540 006c 1268     		ldr	r2, [r2, #0]
 541 006e 42F08002 		orr	r2, r2, #128
 542 0072 03F58053 		add	r3, r3, #4096
 543 0076 03F13403 		add	r3, r3, #52
 544 007a 1A60     		str	r2, [r3, #0]
 286:../Generated_Code/I2C2.c ****   /* I2C1_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 287:../Generated_Code/I2C2.c ****   I2C1_C1 = 0x00U;                     /* Clear control register */
 545              		.loc 1 287 0
 546 007c 4FF4E043 		mov	r3, #28672
 547 0080 C4F20603 		movt	r3, 16390
 548 0084 4FF00002 		mov	r2, #0
 549 0088 9A70     		strb	r2, [r3, #2]
 288:../Generated_Code/I2C2.c ****   /* I2C1_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 289:../Generated_Code/I2C2.c ****   I2C1_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 550              		.loc 1 289 0
 551 008a 4FF4E043 		mov	r3, #28672
 552 008e C4F20603 		movt	r3, 16390
 553 0092 4FF00202 		mov	r2, #2
 554 0096 DA70     		strb	r2, [r3, #3]
 290:../Generated_Code/I2C2.c ****   /* PORTE_PCR0: ISF=0,MUX=6 */
 291:../Generated_Code/I2C2.c ****   PORTE_PCR0 = (uint32_t)((PORTE_PCR0 & (uint32_t)~(uint32_t)(
 555              		.loc 1 291 0
 556 0098 4FF45043 		mov	r3, #53248
 557 009c C4F20403 		movt	r3, 16388
 558 00a0 4FF45042 		mov	r2, #53248
 559 00a4 C4F20402 		movt	r2, 16388
 560 00a8 1268     		ldr	r2, [r2, #0]
 561 00aa 22F08072 		bic	r2, r2, #16777216
 562 00ae 22F4E062 		bic	r2, r2, #1792
 563 00b2 42F4C062 		orr	r2, r2, #1536
 564 00b6 1A60     		str	r2, [r3, #0]
 292:../Generated_Code/I2C2.c ****                 PORT_PCR_ISF_MASK |
 293:../Generated_Code/I2C2.c ****                 PORT_PCR_MUX(0x01)
 294:../Generated_Code/I2C2.c ****                )) | (uint32_t)(
 295:../Generated_Code/I2C2.c ****                 PORT_PCR_MUX(0x06)
 296:../Generated_Code/I2C2.c ****                ));                                                  
 297:../Generated_Code/I2C2.c ****   PORT_PDD_SetPinOpenDrain(PORTE_BASE_PTR, 0x00u, PORT_PDD_OPEN_DRAIN_ENABLE); /* Set SDA pin as op
 565              		.loc 1 297 0
 566 00b8 4FF45043 		mov	r3, #53248
 567 00bc C4F20403 		movt	r3, 16388
 568 00c0 4FF45042 		mov	r2, #53248
 569 00c4 C4F20402 		movt	r2, 16388
 570 00c8 1268     		ldr	r2, [r2, #0]
 571 00ca 22F08072 		bic	r2, r2, #16777216
 572 00ce 22F02002 		bic	r2, r2, #32
 573 00d2 42F02002 		orr	r2, r2, #32
 574 00d6 1A60     		str	r2, [r3, #0]
 298:../Generated_Code/I2C2.c ****   /* PORTE_PCR1: ISF=0,MUX=6 */
 299:../Generated_Code/I2C2.c ****   PORTE_PCR1 = (uint32_t)((PORTE_PCR1 & (uint32_t)~(uint32_t)(
 575              		.loc 1 299 0
 576 00d8 4FF45043 		mov	r3, #53248
 577 00dc C4F20403 		movt	r3, 16388
 578 00e0 4FF45042 		mov	r2, #53248
 579 00e4 C4F20402 		movt	r2, 16388
 580 00e8 5268     		ldr	r2, [r2, #4]
 581 00ea 22F08072 		bic	r2, r2, #16777216
 582 00ee 22F4E062 		bic	r2, r2, #1792
 583 00f2 42F4C062 		orr	r2, r2, #1536
 584 00f6 5A60     		str	r2, [r3, #4]
 300:../Generated_Code/I2C2.c ****                 PORT_PCR_ISF_MASK |
 301:../Generated_Code/I2C2.c ****                 PORT_PCR_MUX(0x01)
 302:../Generated_Code/I2C2.c ****                )) | (uint32_t)(
 303:../Generated_Code/I2C2.c ****                 PORT_PCR_MUX(0x06)
 304:../Generated_Code/I2C2.c ****                ));                                                  
 305:../Generated_Code/I2C2.c ****   PORT_PDD_SetPinOpenDrain(PORTE_BASE_PTR, 0x01u, PORT_PDD_OPEN_DRAIN_ENABLE); /* Set SCL pin as op
 585              		.loc 1 305 0
 586 00f8 4FF45043 		mov	r3, #53248
 587 00fc C4F20403 		movt	r3, 16388
 588 0100 4FF45042 		mov	r2, #53248
 589 0104 C4F20402 		movt	r2, 16388
 590 0108 5268     		ldr	r2, [r2, #4]
 591 010a 22F08072 		bic	r2, r2, #16777216
 592 010e 22F02002 		bic	r2, r2, #32
 593 0112 42F02002 		orr	r2, r2, #32
 594 0116 5A60     		str	r2, [r3, #4]
 306:../Generated_Code/I2C2.c ****   /* NVICIP25: PRI25=0x50 */
 307:../Generated_Code/I2C2.c ****   NVICIP25 = NVIC_IP_PRI25(0x50);                                                   
 595              		.loc 1 307 0
 596 0118 4FF46143 		mov	r3, #57600
 597 011c CEF20003 		movt	r3, 57344
 598 0120 4FF05002 		mov	r2, #80
 599 0124 83F81923 		strb	r2, [r3, #793]
 308:../Generated_Code/I2C2.c ****   /* NVICISER0: SETENA|=0x02000000 */
 309:../Generated_Code/I2C2.c ****   NVICISER0 |= NVIC_ISER_SETENA(0x02000000);                                                   
 600              		.loc 1 309 0
 601 0128 4FF46143 		mov	r3, #57600
 602 012c CEF20003 		movt	r3, 57344
 603 0130 4FF46142 		mov	r2, #57600
 604 0134 CEF20002 		movt	r2, 57344
 605 0138 1268     		ldr	r2, [r2, #0]
 606 013a 42F00072 		orr	r2, r2, #33554432
 607 013e 1A60     		str	r2, [r3, #0]
 310:../Generated_Code/I2C2.c ****   /* I2C1_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 311:../Generated_Code/I2C2.c ****   I2C1_C2 = 0x00U;                                                   
 608              		.loc 1 311 0
 609 0140 4FF4E043 		mov	r3, #28672
 610 0144 C4F20603 		movt	r3, 16390
 611 0148 4FF00002 		mov	r2, #0
 612 014c 5A71     		strb	r2, [r3, #5]
 312:../Generated_Code/I2C2.c ****   /* I2C1_FLT: ??=0,??=0,??=0,FLT=0 */
 313:../Generated_Code/I2C2.c ****   I2C1_FLT = 0x00U;                    /* Set glitch filter register */
 613              		.loc 1 313 0
 614 014e 4FF4E043 		mov	r3, #28672
 615 0152 C4F20603 		movt	r3, 16390
 616 0156 4FF00002 		mov	r2, #0
 617 015a 9A71     		strb	r2, [r3, #6]
 314:../Generated_Code/I2C2.c ****   /* I2C1_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 315:../Generated_Code/I2C2.c ****   I2C1_SMB = I2C_SMB_SLTF_MASK;                                                   
 618              		.loc 1 315 0
 619 015c 4FF4E043 		mov	r3, #28672
 620 0160 C4F20603 		movt	r3, 16390
 621 0164 4FF00802 		mov	r2, #8
 622 0168 1A72     		strb	r2, [r3, #8]
 316:../Generated_Code/I2C2.c ****   /* I2C1_F: MULT=1,ICR=0x19 */
 317:../Generated_Code/I2C2.c ****   I2C1_F = (I2C_F_MULT(0x01) | I2C_F_ICR(0x19)); /* Set prescaler bits */
 623              		.loc 1 317 0
 624 016a 4FF4E043 		mov	r3, #28672
 625 016e C4F20603 		movt	r3, 16390
 626 0172 4FF05902 		mov	r2, #89
 627 0176 5A70     		strb	r2, [r3, #1]
 318:../Generated_Code/I2C2.c ****   I2C_PDD_EnableDevice(I2C1_BASE_PTR, PDD_ENABLE); /* Enable device */
 628              		.loc 1 318 0
 629 0178 4FF4E043 		mov	r3, #28672
 630 017c C4F20603 		movt	r3, 16390
 631 0180 4FF4E042 		mov	r2, #28672
 632 0184 C4F20602 		movt	r2, 16390
 633 0188 9278     		ldrb	r2, [r2, #2]
 634 018a D2B2     		uxtb	r2, r2
 635 018c D2B2     		uxtb	r2, r2
 636 018e 62F07F02 		orn	r2, r2, #127
 637 0192 D2B2     		uxtb	r2, r2
 638 0194 D2B2     		uxtb	r2, r2
 639 0196 9A70     		strb	r2, [r3, #2]
 319:../Generated_Code/I2C2.c ****   I2C_PDD_EnableInterrupt(I2C1_BASE_PTR); /* Enable interrupt */
 640              		.loc 1 319 0
 641 0198 4FF4E043 		mov	r3, #28672
 642 019c C4F20603 		movt	r3, 16390
 643 01a0 4FF4E042 		mov	r2, #28672
 644 01a4 C4F20602 		movt	r2, 16390
 645 01a8 9278     		ldrb	r2, [r2, #2]
 646 01aa D2B2     		uxtb	r2, r2
 647 01ac 42F04002 		orr	r2, r2, #64
 648 01b0 D2B2     		uxtb	r2, r2
 649 01b2 9A70     		strb	r2, [r3, #2]
 320:../Generated_Code/I2C2.c ****   /* Registration of the device structure */
 321:../Generated_Code/I2C2.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID,DeviceDataPrv);
 650              		.loc 1 321 0
 651 01b4 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 652 01b8 C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 653 01bc FA68     		ldr	r2, [r7, #12]
 654 01be 9A62     		str	r2, [r3, #40]
 322:../Generated_Code/I2C2.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 655              		.loc 1 322 0
 656 01c0 FB68     		ldr	r3, [r7, #12]
 323:../Generated_Code/I2C2.c **** }
 657              		.loc 1 323 0
 658 01c2 1846     		mov	r0, r3
 659 01c4 07F11407 		add	r7, r7, #20
 660 01c8 BD46     		mov	sp, r7
 661 01ca 80BC     		pop	{r7}
 662 01cc 7047     		bx	lr
 663              		.cfi_endproc
 664              	.LFE1:
 666 01ce 00BF     		.section	.text.I2C2_Deinit,"ax",%progbits
 667              		.align	2
 668              		.global	I2C2_Deinit
 669              		.thumb
 670              		.thumb_func
 672              	I2C2_Deinit:
 673              	.LFB2:
 324:../Generated_Code/I2C2.c **** 
 325:../Generated_Code/I2C2.c **** /*
 326:../Generated_Code/I2C2.c **** ** ===================================================================
 327:../Generated_Code/I2C2.c **** **     Method      :  I2C2_Deinit (component I2C_LDD)
 328:../Generated_Code/I2C2.c **** **
 329:../Generated_Code/I2C2.c **** **     Description :
 330:../Generated_Code/I2C2.c **** **         Deinitializes the device. Switches off the device, frees the
 331:../Generated_Code/I2C2.c **** **         device data structure memory, interrupts vectors, etc.
 332:../Generated_Code/I2C2.c **** **     Parameters  :
 333:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 334:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 335:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 336:../Generated_Code/I2C2.c **** **     Returns     : Nothing
 337:../Generated_Code/I2C2.c **** ** ===================================================================
 338:../Generated_Code/I2C2.c **** */
 339:../Generated_Code/I2C2.c **** void I2C2_Deinit(LDD_TDeviceData *DeviceDataPtr)
 340:../Generated_Code/I2C2.c **** {
 674              		.loc 1 340 0
 675              		.cfi_startproc
 676              		@ args = 0, pretend = 0, frame = 8
 677              		@ frame_needed = 1, uses_anonymous_args = 0
 678              		@ link register save eliminated.
 679 0000 80B4     		push	{r7}
 680              	.LCFI6:
 681              		.cfi_def_cfa_offset 4
 682              		.cfi_offset 7, -4
 683 0002 83B0     		sub	sp, sp, #12
 684              	.LCFI7:
 685              		.cfi_def_cfa_offset 16
 686 0004 00AF     		add	r7, sp, #0
 687              	.LCFI8:
 688              		.cfi_def_cfa_register 7
 689 0006 7860     		str	r0, [r7, #4]
 341:../Generated_Code/I2C2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 342:../Generated_Code/I2C2.c **** 
 343:../Generated_Code/I2C2.c ****   /* I2C1_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 344:../Generated_Code/I2C2.c ****   I2C1_C1 = 0x00U;                     /* Reset I2C Control register */
 690              		.loc 1 344 0
 691 0008 4FF4E043 		mov	r3, #28672
 692 000c C4F20603 		movt	r3, 16390
 693 0010 4FF00002 		mov	r2, #0
 694 0014 9A70     		strb	r2, [r3, #2]
 345:../Generated_Code/I2C2.c ****   /* Restoring the interrupt vector */
 346:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 347:../Generated_Code/I2C2.c ****   /* Unregistration of the device structure */
 348:../Generated_Code/I2C2.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_I2C2_ID);
 695              		.loc 1 348 0
 696 0016 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 697 001a C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 698 001e 4FF00002 		mov	r2, #0
 699 0022 9A62     		str	r2, [r3, #40]
 349:../Generated_Code/I2C2.c ****   /* Deallocation of the device structure */
 350:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 351:../Generated_Code/I2C2.c ****   /* SIM_SCGC4: I2C1=0 */
 352:../Generated_Code/I2C2.c ****   SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_I2C1_MASK);                                         
 700              		.loc 1 352 0
 701 0024 4FF4E043 		mov	r3, #28672
 702 0028 C4F20403 		movt	r3, 16388
 703 002c 4FF4E042 		mov	r2, #28672
 704 0030 C4F20402 		movt	r2, 16388
 705 0034 02F58052 		add	r2, r2, #4096
 706 0038 02F13402 		add	r2, r2, #52
 707 003c 1268     		ldr	r2, [r2, #0]
 708 003e 22F08002 		bic	r2, r2, #128
 709 0042 03F58053 		add	r3, r3, #4096
 710 0046 03F13403 		add	r3, r3, #52
 711 004a 1A60     		str	r2, [r3, #0]
 353:../Generated_Code/I2C2.c **** }
 712              		.loc 1 353 0
 713 004c 07F10C07 		add	r7, r7, #12
 714 0050 BD46     		mov	sp, r7
 715 0052 80BC     		pop	{r7}
 716 0054 7047     		bx	lr
 717              		.cfi_endproc
 718              	.LFE2:
 720 0056 00BF     		.section	.text.I2C2_MasterSendBlock,"ax",%progbits
 721              		.align	2
 722              		.global	I2C2_MasterSendBlock
 723              		.thumb
 724              		.thumb_func
 726              	I2C2_MasterSendBlock:
 727              	.LFB3:
 354:../Generated_Code/I2C2.c **** 
 355:../Generated_Code/I2C2.c **** /*
 356:../Generated_Code/I2C2.c **** ** ===================================================================
 357:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterSendBlock (component I2C_LDD)
 358:../Generated_Code/I2C2.c **** **
 359:../Generated_Code/I2C2.c **** **     Description :
 360:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 361:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 362:../Generated_Code/I2C2.c **** **         the I2C bus and then writes the block of characters to the
 363:../Generated_Code/I2C2.c **** **         bus. The slave address must be specified before, by the
 364:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 365:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 366:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that transmission was
 367:../Generated_Code/I2C2.c **** **         successful. The state of transmission is detectable by means
 368:../Generated_Code/I2C2.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 369:../Generated_Code/I2C2.c **** **         are not copied to an internal buffer and remains in the
 370:../Generated_Code/I2C2.c **** **         original location. Therefore the content of the buffer
 371:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 372:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 373:../Generated_Code/I2C2.c **** **         the transmission. This method is available only for the
 374:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 375:../Generated_Code/I2C2.c **** **     Parameters  :
 376:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 377:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 378:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 379:../Generated_Code/I2C2.c **** **       * BufferPtr       - Pointer to the block of data
 380:../Generated_Code/I2C2.c **** **                           to send.
 381:../Generated_Code/I2C2.c **** **         Size            - Size of the data block.
 382:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 383:../Generated_Code/I2C2.c **** **                           Stop condition
 384:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 385:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 386:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 387:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 388:../Generated_Code/I2C2.c **** **     Returns     :
 389:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 390:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 391:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 392:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 393:../Generated_Code/I2C2.c **** **                           the active clock configuration
 394:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The I2C device is now running
 395:../Generated_Code/I2C2.c **** ** ===================================================================
 396:../Generated_Code/I2C2.c **** */
 397:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TSize
 398:../Generated_Code/I2C2.c **** {
 728              		.loc 1 398 0
 729              		.cfi_startproc
 730              		@ args = 0, pretend = 0, frame = 24
 731              		@ frame_needed = 1, uses_anonymous_args = 0
 732              		@ link register save eliminated.
 733 0000 80B4     		push	{r7}
 734              	.LCFI9:
 735              		.cfi_def_cfa_offset 4
 736              		.cfi_offset 7, -4
 737 0002 87B0     		sub	sp, sp, #28
 738              	.LCFI10:
 739              		.cfi_def_cfa_offset 32
 740 0004 00AF     		add	r7, sp, #0
 741              	.LCFI11:
 742              		.cfi_def_cfa_register 7
 743 0006 F860     		str	r0, [r7, #12]
 744 0008 B960     		str	r1, [r7, #8]
 745 000a FA80     		strh	r2, [r7, #6]	@ movhi
 746 000c 7B71     		strb	r3, [r7, #5]
 399:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 747              		.loc 1 399 0
 748 000e FB68     		ldr	r3, [r7, #12]
 749 0010 7B61     		str	r3, [r7, #20]
 400:../Generated_Code/I2C2.c **** 
 401:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 750              		.loc 1 401 0
 751 0012 FB88     		ldrh	r3, [r7, #6]
 752 0014 002B     		cmp	r3, #0
 753 0016 02D1     		bne	.L19
 402:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 754              		.loc 1 402 0
 755 0018 4FF00003 		mov	r3, #0
 756 001c E5E0     		b	.L20
 757              	.L19:
 403:../Generated_Code/I2C2.c ****   }
 404:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 758              		.loc 1 404 0
 759 001e 7B69     		ldr	r3, [r7, #20]
 760 0020 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 761 0022 012B     		cmp	r3, #1
 762 0024 17D1     		bne	.L21
 405:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 763              		.loc 1 405 0
 764 0026 4FF4E043 		mov	r3, #28672
 765 002a C4F20603 		movt	r3, 16390
 766 002e DB78     		ldrb	r3, [r3, #3]
 767 0030 DBB2     		uxtb	r3, r3
 768 0032 03F02003 		and	r3, r3, #32
 769 0036 002B     		cmp	r3, #0
 770 0038 0AD1     		bne	.L22
 406:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 771              		.loc 1 406 0 discriminator 1
 772 003a 7B69     		ldr	r3, [r7, #20]
 773 003c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 774 003e 03F00103 		and	r3, r3, #1
 775 0042 DBB2     		uxtb	r3, r3
 405:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 776              		.loc 1 405 0 discriminator 1
 777 0044 002B     		cmp	r3, #0
 778 0046 03D1     		bne	.L22
 407:../Generated_Code/I2C2.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 779              		.loc 1 407 0
 780 0048 7B69     		ldr	r3, [r7, #20]
 781 004a 9B89     		ldrh	r3, [r3, #12]
 406:../Generated_Code/I2C2.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 782              		.loc 1 406 0
 783 004c 002B     		cmp	r3, #0
 784 004e 10D0     		beq	.L23
 785              	.L22:
 408:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 786              		.loc 1 408 0
 787 0050 4FF00803 		mov	r3, #8
 788 0054 C9E0     		b	.L20
 789              	.L21:
 409:../Generated_Code/I2C2.c ****     }
 410:../Generated_Code/I2C2.c ****   } else {
 411:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 790              		.loc 1 411 0
 791 0056 7B69     		ldr	r3, [r7, #20]
 792 0058 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 793 005a 03F00103 		and	r3, r3, #1
 794 005e DBB2     		uxtb	r3, r3
 795 0060 002B     		cmp	r3, #0
 796 0062 03D1     		bne	.L24
 412:../Generated_Code/I2C2.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 797              		.loc 1 412 0 discriminator 1
 798 0064 7B69     		ldr	r3, [r7, #20]
 799 0066 9B89     		ldrh	r3, [r3, #12]
 411:../Generated_Code/I2C2.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 800              		.loc 1 411 0 discriminator 1
 801 0068 002B     		cmp	r3, #0
 802 006a 02D0     		beq	.L23
 803              	.L24:
 413:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 804              		.loc 1 413 0
 805 006c 4FF00803 		mov	r3, #8
 806 0070 BBE0     		b	.L20
 807              	.L23:
 414:../Generated_Code/I2C2.c ****     }
 415:../Generated_Code/I2C2.c ****   }
 416:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 417:../Generated_Code/I2C2.c ****   EnterCritical();
 808              		.loc 1 417 0
 809 0072 40F20003 		movw	r3, #:lower16:SR_lock
 810 0076 C0F20003 		movt	r3, #:upper16:SR_lock
 811 007a 1B78     		ldrb	r3, [r3, #0]
 812 007c DBB2     		uxtb	r3, r3
 813 007e 03F10103 		add	r3, r3, #1
 814 0082 DBB2     		uxtb	r3, r3
 815 0084 1A46     		mov	r2, r3
 816 0086 40F20003 		movw	r3, #:lower16:SR_lock
 817 008a C0F20003 		movt	r3, #:upper16:SR_lock
 818 008e 1146     		mov	r1, r2
 819 0090 1970     		strb	r1, [r3, #0]
 820 0092 012A     		cmp	r2, #1
 821 0094 07D1     		bne	.L25
 822              		.loc 1 417 0 is_stmt 0 discriminator 1
 823 0096 40F20003 		movw	r3, #:lower16:SR_reg
 824 009a C0F20003 		movt	r3, #:upper16:SR_reg
 825              	@ 417 "../Generated_Code/I2C2.c" 1
 826 009e EFF31380 		MRS R0, FAULTMASK
 827 00a2 71B6     		CPSID f
 828 00a4 1870     		STRB R0, [r3, #0]
 829              	@ 0 "" 2
 830              		.thumb
 831              	.L25:
 418:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 832              		.loc 1 418 0 is_stmt 1
 833 00a6 7B69     		ldr	r3, [r7, #20]
 834 00a8 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 835 00aa 43F00103 		orr	r3, r3, #1
 836 00ae DAB2     		uxtb	r2, r3
 837 00b0 7B69     		ldr	r3, [r7, #20]
 838 00b2 1A70     		strb	r2, [r3, #0]
 419:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 839              		.loc 1 419 0
 840 00b4 7B69     		ldr	r3, [r7, #20]
 841 00b6 BA68     		ldr	r2, [r7, #8]
 842 00b8 1A61     		str	r2, [r3, #16]
 420:../Generated_Code/I2C2.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 843              		.loc 1 420 0
 844 00ba 7B69     		ldr	r3, [r7, #20]
 845 00bc FA88     		ldrh	r2, [r7, #6]	@ movhi
 846 00be 9A81     		strh	r2, [r3, #12]	@ movhi
 421:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 847              		.loc 1 421 0
 848 00c0 7B69     		ldr	r3, [r7, #20]
 849 00c2 7A79     		ldrb	r2, [r7, #5]
 850 00c4 5A70     		strb	r2, [r3, #1]
 422:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 851              		.loc 1 422 0
 852 00c6 4FF4E043 		mov	r3, #28672
 853 00ca C4F20603 		movt	r3, 16390
 854 00ce 4FF4E042 		mov	r2, #28672
 855 00d2 C4F20602 		movt	r2, 16390
 856 00d6 9278     		ldrb	r2, [r2, #2]
 857 00d8 D2B2     		uxtb	r2, r2
 858 00da D2B2     		uxtb	r2, r2
 859 00dc 42F01002 		orr	r2, r2, #16
 860 00e0 D2B2     		uxtb	r2, r2
 861 00e2 D2B2     		uxtb	r2, r2
 862 00e4 9A70     		strb	r2, [r3, #2]
 423:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 863              		.loc 1 423 0
 864 00e6 4FF4E043 		mov	r3, #28672
 865 00ea C4F20603 		movt	r3, 16390
 866 00ee 9B78     		ldrb	r3, [r3, #2]
 867 00f0 DBB2     		uxtb	r3, r3
 868 00f2 03F02003 		and	r3, r3, #32
 869 00f6 002B     		cmp	r3, #0
 870 00f8 0ED0     		beq	.L26
 424:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* If yes then repeat start cycle generated */
 871              		.loc 1 424 0
 872 00fa 4FF4E043 		mov	r3, #28672
 873 00fe C4F20603 		movt	r3, 16390
 874 0102 4FF4E042 		mov	r2, #28672
 875 0106 C4F20602 		movt	r2, 16390
 876 010a 9278     		ldrb	r2, [r2, #2]
 877 010c D2B2     		uxtb	r2, r2
 878 010e 42F00402 		orr	r2, r2, #4
 879 0112 D2B2     		uxtb	r2, r2
 880 0114 9A70     		strb	r2, [r3, #2]
 881 0116 0FE0     		b	.L27
 882              	.L26:
 425:../Generated_Code/I2C2.c ****   } else {
 426:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 883              		.loc 1 426 0
 884 0118 4FF4E043 		mov	r3, #28672
 885 011c C4F20603 		movt	r3, 16390
 886 0120 4FF4E042 		mov	r2, #28672
 887 0124 C4F20602 		movt	r2, 16390
 888 0128 9278     		ldrb	r2, [r2, #2]
 889 012a D2B2     		uxtb	r2, r2
 890 012c D2B2     		uxtb	r2, r2
 891 012e 42F02002 		orr	r2, r2, #32
 892 0132 D2B2     		uxtb	r2, r2
 893 0134 D2B2     		uxtb	r2, r2
 894 0136 9A70     		strb	r2, [r3, #2]
 895              	.L27:
 427:../Generated_Code/I2C2.c ****   }
 428:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 896              		.loc 1 428 0
 897 0138 7B69     		ldr	r3, [r7, #20]
 898 013a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 899 013c 03F02003 		and	r3, r3, #32
 900 0140 002B     		cmp	r3, #0
 901 0142 0ED0     		beq	.L28
 429:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Only one byte of address will
 902              		.loc 1 429 0
 903 0144 7B69     		ldr	r3, [r7, #20]
 904 0146 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 905 0148 43F00603 		orr	r3, r3, #6
 906 014c DAB2     		uxtb	r2, r3
 907 014e 7B69     		ldr	r3, [r7, #20]
 908 0150 1A70     		strb	r2, [r3, #0]
 430:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddr); /* Send slave address */
 909              		.loc 1 430 0
 910 0152 4FF4E043 		mov	r3, #28672
 911 0156 C4F20603 		movt	r3, 16390
 912 015a 7A69     		ldr	r2, [r7, #20]
 913 015c 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 914 015e 1A71     		strb	r2, [r3, #4]
 915 0160 28E0     		b	.L29
 916              	.L28:
 431:../Generated_Code/I2C2.c ****   } else {
 432:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 917              		.loc 1 432 0
 918 0162 7B69     		ldr	r3, [r7, #20]
 919 0164 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 920 0166 03F01003 		and	r3, r3, #16
 921 016a 002B     		cmp	r3, #0
 922 016c 0ED0     		beq	.L30
 433:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 923              		.loc 1 433 0
 924 016e 7B69     		ldr	r3, [r7, #20]
 925 0170 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 926 0172 23F00603 		bic	r3, r3, #6
 927 0176 DAB2     		uxtb	r2, r3
 928 0178 7B69     		ldr	r3, [r7, #20]
 929 017a 1A70     		strb	r2, [r3, #0]
 434:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 930              		.loc 1 434 0
 931 017c 4FF4E043 		mov	r3, #28672
 932 0180 C4F20603 		movt	r3, 16390
 933 0184 7A69     		ldr	r2, [r7, #20]
 934 0186 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 935 0188 1A71     		strb	r2, [r3, #4]
 936 018a 13E0     		b	.L29
 937              	.L30:
 435:../Generated_Code/I2C2.c ****     } else {
 436:../Generated_Code/I2C2.c ****       if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is general call command required ?
 938              		.loc 1 436 0
 939 018c 7B69     		ldr	r3, [r7, #20]
 940 018e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 941 0190 03F00803 		and	r3, r3, #8
 942 0194 002B     		cmp	r3, #0
 943 0196 0DD0     		beq	.L29
 437:../Generated_Code/I2C2.c ****         DeviceDataPrv->SerFlag |= ADDR_COMPLETE; /* Only one byte of address will be sent in genera
 944              		.loc 1 437 0
 945 0198 7B69     		ldr	r3, [r7, #20]
 946 019a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 947 019c 43F00203 		orr	r3, r3, #2
 948 01a0 DAB2     		uxtb	r2, r3
 949 01a2 7B69     		ldr	r3, [r7, #20]
 950 01a4 1A70     		strb	r2, [r3, #0]
 438:../Generated_Code/I2C2.c ****         I2C_PDD_WriteDataReg(I2C1_BASE_PTR, 0x00U); /* Send general call address */
 951              		.loc 1 438 0
 952 01a6 4FF4E043 		mov	r3, #28672
 953 01aa C4F20603 		movt	r3, 16390
 954 01ae 4FF00002 		mov	r2, #0
 955 01b2 1A71     		strb	r2, [r3, #4]
 956              	.L29:
 439:../Generated_Code/I2C2.c ****       }
 440:../Generated_Code/I2C2.c ****     }
 441:../Generated_Code/I2C2.c ****   }
 442:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 443:../Generated_Code/I2C2.c ****   ExitCritical();
 957              		.loc 1 443 0
 958 01b4 40F20003 		movw	r3, #:lower16:SR_lock
 959 01b8 C0F20003 		movt	r3, #:upper16:SR_lock
 960 01bc 1B78     		ldrb	r3, [r3, #0]
 961 01be DBB2     		uxtb	r3, r3
 962 01c0 03F1FF33 		add	r3, r3, #-1
 963 01c4 DBB2     		uxtb	r3, r3
 964 01c6 1A46     		mov	r2, r3
 965 01c8 40F20003 		movw	r3, #:lower16:SR_lock
 966 01cc C0F20003 		movt	r3, #:upper16:SR_lock
 967 01d0 1146     		mov	r1, r2
 968 01d2 1970     		strb	r1, [r3, #0]
 969 01d4 002A     		cmp	r2, #0
 970 01d6 06D1     		bne	.L31
 971              		.loc 1 443 0 is_stmt 0 discriminator 1
 972 01d8 40F20003 		movw	r3, #:lower16:SR_reg
 973 01dc C0F20003 		movt	r3, #:upper16:SR_reg
 974              	@ 443 "../Generated_Code/I2C2.c" 1
 975 01e0 1878     		ldrb r0, [r3, #0]
 976 01e2 80F31388 		msr FAULTMASK,r0;
 977              		
 978              	@ 0 "" 2
 979              		.thumb
 980              	.L31:
 444:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 981              		.loc 1 444 0 is_stmt 1
 982 01e6 4FF00003 		mov	r3, #0
 983              	.L20:
 445:../Generated_Code/I2C2.c **** }
 984              		.loc 1 445 0
 985 01ea 1846     		mov	r0, r3
 986 01ec 07F11C07 		add	r7, r7, #28
 987 01f0 BD46     		mov	sp, r7
 988 01f2 80BC     		pop	{r7}
 989 01f4 7047     		bx	lr
 990              		.cfi_endproc
 991              	.LFE3:
 993 01f6 00BF     		.section	.text.I2C2_MasterReceiveBlock,"ax",%progbits
 994              		.align	2
 995              		.global	I2C2_MasterReceiveBlock
 996              		.thumb
 997              		.thumb_func
 999              	I2C2_MasterReceiveBlock:
 1000              	.LFB4:
 446:../Generated_Code/I2C2.c **** 
 447:../Generated_Code/I2C2.c **** /*
 448:../Generated_Code/I2C2.c **** ** ===================================================================
 449:../Generated_Code/I2C2.c **** **     Method      :  I2C2_MasterReceiveBlock (component I2C_LDD)
 450:../Generated_Code/I2C2.c **** **
 451:../Generated_Code/I2C2.c **** **     Description :
 452:../Generated_Code/I2C2.c **** **         This method writes one (7-bit addressing) or two (10-bit
 453:../Generated_Code/I2C2.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 454:../Generated_Code/I2C2.c **** **         the I2C bus and then receives the block of characters from
 455:../Generated_Code/I2C2.c **** **         the bus. The slave address must be specified before, by the
 456:../Generated_Code/I2C2.c **** **         "SelectSlaveDevice" method or in component initialization
 457:../Generated_Code/I2C2.c **** **         section, "Target slave address init" property. If the method
 458:../Generated_Code/I2C2.c **** **         returns ERR_OK, it doesn't mean that reception was
 459:../Generated_Code/I2C2.c **** **         successful. The state of reception is detectable by means of
 460:../Generated_Code/I2C2.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 461:../Generated_Code/I2C2.c **** **         received are not copied to an internal buffer and remains in
 462:../Generated_Code/I2C2.c **** **         the original location. Therefore the content of the buffer
 463:../Generated_Code/I2C2.c **** **         should not be changed until the transmission is complete.
 464:../Generated_Code/I2C2.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 465:../Generated_Code/I2C2.c **** **         of the reception. This method is available only for the
 466:../Generated_Code/I2C2.c **** **         MASTER or MASTER - SLAVE mode.
 467:../Generated_Code/I2C2.c **** **     Parameters  :
 468:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 469:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 470:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 471:../Generated_Code/I2C2.c **** **       * BufferPtr       - Pointer to a buffer where
 472:../Generated_Code/I2C2.c **** **                           received characters will be stored.
 473:../Generated_Code/I2C2.c **** **         Size            - The size of the block.
 474:../Generated_Code/I2C2.c **** **         SendStop        - Parameter for generating I2C
 475:../Generated_Code/I2C2.c **** **                           Stop condition
 476:../Generated_Code/I2C2.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 477:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 478:../Generated_Code/I2C2.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 479:../Generated_Code/I2C2.c **** **                           generated on end transmission.
 480:../Generated_Code/I2C2.c **** **     Returns     :
 481:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 482:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 483:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 484:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 485:../Generated_Code/I2C2.c **** **                           the active clock configuration
 486:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The master device is busy
 487:../Generated_Code/I2C2.c **** **                           ERR_NOTAVAIL - It is not possible to
 488:../Generated_Code/I2C2.c **** **                           receive data if general call address is set.
 489:../Generated_Code/I2C2.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 490:../Generated_Code/I2C2.c **** **                           possible generated on end transmission.
 491:../Generated_Code/I2C2.c **** ** ===================================================================
 492:../Generated_Code/I2C2.c **** */
 493:../Generated_Code/I2C2.c **** LDD_TError I2C2_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 494:../Generated_Code/I2C2.c **** {
 1001              		.loc 1 494 0
 1002              		.cfi_startproc
 1003              		@ args = 0, pretend = 0, frame = 24
 1004              		@ frame_needed = 1, uses_anonymous_args = 0
 1005              		@ link register save eliminated.
 1006 0000 80B4     		push	{r7}
 1007              	.LCFI12:
 1008              		.cfi_def_cfa_offset 4
 1009              		.cfi_offset 7, -4
 1010 0002 87B0     		sub	sp, sp, #28
 1011              	.LCFI13:
 1012              		.cfi_def_cfa_offset 32
 1013 0004 00AF     		add	r7, sp, #0
 1014              	.LCFI14:
 1015              		.cfi_def_cfa_register 7
 1016 0006 F860     		str	r0, [r7, #12]
 1017 0008 B960     		str	r1, [r7, #8]
 1018 000a FA80     		strh	r2, [r7, #6]	@ movhi
 1019 000c 7B71     		strb	r3, [r7, #5]
 495:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1020              		.loc 1 495 0
 1021 000e FB68     		ldr	r3, [r7, #12]
 1022 0010 7B61     		str	r3, [r7, #20]
 496:../Generated_Code/I2C2.c **** 
 497:../Generated_Code/I2C2.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 1023              		.loc 1 497 0
 1024 0012 FB88     		ldrh	r3, [r7, #6]
 1025 0014 002B     		cmp	r3, #0
 1026 0016 02D1     		bne	.L33
 498:../Generated_Code/I2C2.c ****     return ERR_OK;                     /* If zero then OK */
 1027              		.loc 1 498 0
 1028 0018 4FF00003 		mov	r3, #0
 1029 001c E2E0     		b	.L34
 1030              	.L33:
 499:../Generated_Code/I2C2.c ****   }
 500:../Generated_Code/I2C2.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 1031              		.loc 1 500 0
 1032 001e 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1033 0020 002B     		cmp	r3, #0
 1034 0022 02D1     		bne	.L35
 501:../Generated_Code/I2C2.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 1035              		.loc 1 501 0
 1036 0024 4FF08103 		mov	r3, #129
 1037 0028 DCE0     		b	.L34
 1038              	.L35:
 502:../Generated_Code/I2C2.c ****   }
 503:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & GENERAL_CALL) != 0x00U) { /* Is the general call flag set (SelectSl
 1039              		.loc 1 503 0
 1040 002a 7B69     		ldr	r3, [r7, #20]
 1041 002c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1042 002e 03F00803 		and	r3, r3, #8
 1043 0032 002B     		cmp	r3, #0
 1044 0034 02D0     		beq	.L36
 504:../Generated_Code/I2C2.c ****     return ERR_NOTAVAIL;               /* It is not possible to receive data - Call SelectSlaveDevi
 1045              		.loc 1 504 0
 1046 0036 4FF00903 		mov	r3, #9
 1047 003a D3E0     		b	.L34
 1048              	.L36:
 505:../Generated_Code/I2C2.c ****   }
 506:../Generated_Code/I2C2.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 1049              		.loc 1 506 0
 1050 003c 7B69     		ldr	r3, [r7, #20]
 1051 003e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1052 0040 012B     		cmp	r3, #1
 1053 0042 17D1     		bne	.L37
 507:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1054              		.loc 1 507 0
 1055 0044 4FF4E043 		mov	r3, #28672
 1056 0048 C4F20603 		movt	r3, 16390
 1057 004c DB78     		ldrb	r3, [r3, #3]
 1058 004e DBB2     		uxtb	r3, r3
 1059 0050 03F02003 		and	r3, r3, #32
 1060 0054 002B     		cmp	r3, #0
 1061 0056 0AD1     		bne	.L38
 508:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1062              		.loc 1 508 0 discriminator 1
 1063 0058 7B69     		ldr	r3, [r7, #20]
 1064 005a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1065 005c 03F00103 		and	r3, r3, #1
 1066 0060 DBB2     		uxtb	r3, r3
 507:../Generated_Code/I2C2.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 1067              		.loc 1 507 0 discriminator 1
 1068 0062 002B     		cmp	r3, #0
 1069 0064 03D1     		bne	.L38
 509:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1070              		.loc 1 509 0
 1071 0066 7B69     		ldr	r3, [r7, #20]
 1072 0068 DB88     		ldrh	r3, [r3, #6]
 508:../Generated_Code/I2C2.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 1073              		.loc 1 508 0
 1074 006a 002B     		cmp	r3, #0
 1075 006c 10D0     		beq	.L39
 1076              	.L38:
 510:../Generated_Code/I2C2.c ****       return ERR_BUSY;                 /* If yes then error */
 1077              		.loc 1 510 0
 1078 006e 4FF00803 		mov	r3, #8
 1079 0072 B7E0     		b	.L34
 1080              	.L37:
 511:../Generated_Code/I2C2.c ****     }
 512:../Generated_Code/I2C2.c ****   } else {
 513:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1081              		.loc 1 513 0
 1082 0074 7B69     		ldr	r3, [r7, #20]
 1083 0076 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1084 0078 03F00103 		and	r3, r3, #1
 1085 007c DBB2     		uxtb	r3, r3
 1086 007e 002B     		cmp	r3, #0
 1087 0080 03D1     		bne	.L40
 514:../Generated_Code/I2C2.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 1088              		.loc 1 514 0 discriminator 1
 1089 0082 7B69     		ldr	r3, [r7, #20]
 1090 0084 DB88     		ldrh	r3, [r3, #6]
 513:../Generated_Code/I2C2.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 1091              		.loc 1 513 0 discriminator 1
 1092 0086 002B     		cmp	r3, #0
 1093 0088 02D0     		beq	.L39
 1094              	.L40:
 515:../Generated_Code/I2C2.c ****       return ERR_BUSY;               /* If yes then error */
 1095              		.loc 1 515 0
 1096 008a 4FF00803 		mov	r3, #8
 1097 008e A9E0     		b	.L34
 1098              	.L39:
 516:../Generated_Code/I2C2.c ****     }
 517:../Generated_Code/I2C2.c ****   }
 518:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 519:../Generated_Code/I2C2.c ****   EnterCritical();
 1099              		.loc 1 519 0
 1100 0090 40F20003 		movw	r3, #:lower16:SR_lock
 1101 0094 C0F20003 		movt	r3, #:upper16:SR_lock
 1102 0098 1B78     		ldrb	r3, [r3, #0]
 1103 009a DBB2     		uxtb	r3, r3
 1104 009c 03F10103 		add	r3, r3, #1
 1105 00a0 DBB2     		uxtb	r3, r3
 1106 00a2 1A46     		mov	r2, r3
 1107 00a4 40F20003 		movw	r3, #:lower16:SR_lock
 1108 00a8 C0F20003 		movt	r3, #:upper16:SR_lock
 1109 00ac 1146     		mov	r1, r2
 1110 00ae 1970     		strb	r1, [r3, #0]
 1111 00b0 012A     		cmp	r2, #1
 1112 00b2 07D1     		bne	.L41
 1113              		.loc 1 519 0 is_stmt 0 discriminator 1
 1114 00b4 40F20003 		movw	r3, #:lower16:SR_reg
 1115 00b8 C0F20003 		movt	r3, #:upper16:SR_reg
 1116              	@ 519 "../Generated_Code/I2C2.c" 1
 1117 00bc EFF31380 		MRS R0, FAULTMASK
 1118 00c0 71B6     		CPSID f
 1119 00c2 1870     		STRB R0, [r3, #0]
 1120              	@ 0 "" 2
 1121              		.thumb
 1122              	.L41:
 520:../Generated_Code/I2C2.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 1123              		.loc 1 520 0 is_stmt 1
 1124 00c4 7B69     		ldr	r3, [r7, #20]
 1125 00c6 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1126 00c8 43F00103 		orr	r3, r3, #1
 1127 00cc DAB2     		uxtb	r2, r3
 1128 00ce 7B69     		ldr	r3, [r7, #20]
 1129 00d0 1A70     		strb	r2, [r3, #0]
 521:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 1130              		.loc 1 521 0
 1131 00d2 7B69     		ldr	r3, [r7, #20]
 1132 00d4 BA68     		ldr	r2, [r7, #8]
 1133 00d6 9A60     		str	r2, [r3, #8]
 522:../Generated_Code/I2C2.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 1134              		.loc 1 522 0
 1135 00d8 7B69     		ldr	r3, [r7, #20]
 1136 00da FA88     		ldrh	r2, [r7, #6]	@ movhi
 1137 00dc DA80     		strh	r2, [r3, #6]	@ movhi
 523:../Generated_Code/I2C2.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 1138              		.loc 1 523 0
 1139 00de 7B69     		ldr	r3, [r7, #20]
 1140 00e0 7A79     		ldrb	r2, [r7, #5]
 1141 00e2 5A70     		strb	r2, [r3, #1]
 524:../Generated_Code/I2C2.c ****   I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 1142              		.loc 1 524 0
 1143 00e4 4FF4E043 		mov	r3, #28672
 1144 00e8 C4F20603 		movt	r3, 16390
 1145 00ec 4FF4E042 		mov	r2, #28672
 1146 00f0 C4F20602 		movt	r2, 16390
 1147 00f4 9278     		ldrb	r2, [r2, #2]
 1148 00f6 D2B2     		uxtb	r2, r2
 1149 00f8 D2B2     		uxtb	r2, r2
 1150 00fa 42F01002 		orr	r2, r2, #16
 1151 00fe D2B2     		uxtb	r2, r2
 1152 0100 D2B2     		uxtb	r2, r2
 1153 0102 9A70     		strb	r2, [r3, #2]
 525:../Generated_Code/I2C2.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 1154              		.loc 1 525 0
 1155 0104 4FF4E043 		mov	r3, #28672
 1156 0108 C4F20603 		movt	r3, 16390
 1157 010c 9B78     		ldrb	r3, [r3, #2]
 1158 010e DBB2     		uxtb	r3, r3
 1159 0110 03F02003 		and	r3, r3, #32
 1160 0114 002B     		cmp	r3, #0
 1161 0116 0ED0     		beq	.L42
 526:../Generated_Code/I2C2.c ****     I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* If yes then repeat start cycle generated */
 1162              		.loc 1 526 0
 1163 0118 4FF4E043 		mov	r3, #28672
 1164 011c C4F20603 		movt	r3, 16390
 1165 0120 4FF4E042 		mov	r2, #28672
 1166 0124 C4F20602 		movt	r2, 16390
 1167 0128 9278     		ldrb	r2, [r2, #2]
 1168 012a D2B2     		uxtb	r2, r2
 1169 012c 42F00402 		orr	r2, r2, #4
 1170 0130 D2B2     		uxtb	r2, r2
 1171 0132 9A70     		strb	r2, [r3, #2]
 1172 0134 0FE0     		b	.L43
 1173              	.L42:
 527:../Generated_Code/I2C2.c ****   } else {
 528:../Generated_Code/I2C2.c ****     I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 1174              		.loc 1 528 0
 1175 0136 4FF4E043 		mov	r3, #28672
 1176 013a C4F20603 		movt	r3, 16390
 1177 013e 4FF4E042 		mov	r2, #28672
 1178 0142 C4F20602 		movt	r2, 16390
 1179 0146 9278     		ldrb	r2, [r2, #2]
 1180 0148 D2B2     		uxtb	r2, r2
 1181 014a D2B2     		uxtb	r2, r2
 1182 014c 42F02002 		orr	r2, r2, #32
 1183 0150 D2B2     		uxtb	r2, r2
 1184 0152 D2B2     		uxtb	r2, r2
 1185 0154 9A70     		strb	r2, [r3, #2]
 1186              	.L43:
 529:../Generated_Code/I2C2.c ****   }
 530:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & ADDR_7) != 0x00U) { /* Is 7-bit addressing set ? */
 1187              		.loc 1 530 0
 1188 0156 7B69     		ldr	r3, [r7, #20]
 1189 0158 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1190 015a 03F02003 		and	r3, r3, #32
 1191 015e 002B     		cmp	r3, #0
 1192 0160 11D0     		beq	.L44
 531:../Generated_Code/I2C2.c ****     DeviceDataPrv->SerFlag |= (ADDR_COMPLETE|REP_ADDR_COMPLETE); /* Only one byte of address will b
 1193              		.loc 1 531 0
 1194 0162 7B69     		ldr	r3, [r7, #20]
 1195 0164 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1196 0166 43F00603 		orr	r3, r3, #6
 1197 016a DAB2     		uxtb	r2, r3
 1198 016c 7B69     		ldr	r3, [r7, #20]
 1199 016e 1A70     		strb	r2, [r3, #0]
 532:../Generated_Code/I2C2.c ****     I2C_PDD_WriteDataReg(I2C1_BASE_PTR, (uint8_t)(DeviceDataPrv->SlaveAddr | 0x01U)); /* Send slave
 1200              		.loc 1 532 0
 1201 0170 4FF4E043 		mov	r3, #28672
 1202 0174 C4F20603 		movt	r3, 16390
 1203 0178 7A69     		ldr	r2, [r7, #20]
 1204 017a 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 1205 017c 42F00102 		orr	r2, r2, #1
 1206 0180 D2B2     		uxtb	r2, r2
 1207 0182 1A71     		strb	r2, [r3, #4]
 1208 0184 13E0     		b	.L45
 1209              	.L44:
 533:../Generated_Code/I2C2.c ****   } else {
 534:../Generated_Code/I2C2.c ****     if ((DeviceDataPrv->SerFlag & ADDR_10) != 0x00U) { /* Is 10-bit addressing set ? */
 1210              		.loc 1 534 0
 1211 0186 7B69     		ldr	r3, [r7, #20]
 1212 0188 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1213 018a 03F01003 		and	r3, r3, #16
 1214 018e 002B     		cmp	r3, #0
 1215 0190 0DD0     		beq	.L45
 535:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_COMPLETE | REP_ADDR_COMPLETE); /* Second byte of ad
 1216              		.loc 1 535 0
 1217 0192 7B69     		ldr	r3, [r7, #20]
 1218 0194 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1219 0196 23F00603 		bic	r3, r3, #6
 1220 019a DAB2     		uxtb	r2, r3
 1221 019c 7B69     		ldr	r3, [r7, #20]
 1222 019e 1A70     		strb	r2, [r3, #0]
 536:../Generated_Code/I2C2.c ****       I2C_PDD_WriteDataReg(I2C1_BASE_PTR, DeviceDataPrv->SlaveAddrHigh); /* Send slave address - hi
 1223              		.loc 1 536 0
 1224 01a0 4FF4E043 		mov	r3, #28672
 1225 01a4 C4F20603 		movt	r3, 16390
 1226 01a8 7A69     		ldr	r2, [r7, #20]
 1227 01aa 5279     		ldrb	r2, [r2, #5]	@ zero_extendqisi2
 1228 01ac 1A71     		strb	r2, [r3, #4]
 1229              	.L45:
 537:../Generated_Code/I2C2.c ****     }
 538:../Generated_Code/I2C2.c ****   }
 539:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 540:../Generated_Code/I2C2.c ****   ExitCritical();
 1230              		.loc 1 540 0
 1231 01ae 40F20003 		movw	r3, #:lower16:SR_lock
 1232 01b2 C0F20003 		movt	r3, #:upper16:SR_lock
 1233 01b6 1B78     		ldrb	r3, [r3, #0]
 1234 01b8 DBB2     		uxtb	r3, r3
 1235 01ba 03F1FF33 		add	r3, r3, #-1
 1236 01be DBB2     		uxtb	r3, r3
 1237 01c0 1A46     		mov	r2, r3
 1238 01c2 40F20003 		movw	r3, #:lower16:SR_lock
 1239 01c6 C0F20003 		movt	r3, #:upper16:SR_lock
 1240 01ca 1146     		mov	r1, r2
 1241 01cc 1970     		strb	r1, [r3, #0]
 1242 01ce 002A     		cmp	r2, #0
 1243 01d0 06D1     		bne	.L46
 1244              		.loc 1 540 0 is_stmt 0 discriminator 1
 1245 01d2 40F20003 		movw	r3, #:lower16:SR_reg
 1246 01d6 C0F20003 		movt	r3, #:upper16:SR_reg
 1247              	@ 540 "../Generated_Code/I2C2.c" 1
 1248 01da 1878     		ldrb r0, [r3, #0]
 1249 01dc 80F31388 		msr FAULTMASK,r0;
 1250              		
 1251              	@ 0 "" 2
 1252              		.thumb
 1253              	.L46:
 541:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1254              		.loc 1 541 0 is_stmt 1
 1255 01e0 4FF00003 		mov	r3, #0
 1256              	.L34:
 542:../Generated_Code/I2C2.c **** }
 1257              		.loc 1 542 0
 1258 01e4 1846     		mov	r0, r3
 1259 01e6 07F11C07 		add	r7, r7, #28
 1260 01ea BD46     		mov	sp, r7
 1261 01ec 80BC     		pop	{r7}
 1262 01ee 7047     		bx	lr
 1263              		.cfi_endproc
 1264              	.LFE4:
 1266              		.section	.text.I2C2_SelectSlaveDevice,"ax",%progbits
 1267              		.align	2
 1268              		.global	I2C2_SelectSlaveDevice
 1269              		.thumb
 1270              		.thumb_func
 1272              	I2C2_SelectSlaveDevice:
 1273              	.LFB5:
 543:../Generated_Code/I2C2.c **** 
 544:../Generated_Code/I2C2.c **** /*
 545:../Generated_Code/I2C2.c **** ** ===================================================================
 546:../Generated_Code/I2C2.c **** **     Method      :  I2C2_SelectSlaveDevice (component I2C_LDD)
 547:../Generated_Code/I2C2.c **** **
 548:../Generated_Code/I2C2.c **** **     Description :
 549:../Generated_Code/I2C2.c **** **         This method selects a new slave for communication by its
 550:../Generated_Code/I2C2.c **** **         7-bit slave, 10-bit address or general call value. Any send
 551:../Generated_Code/I2C2.c **** **         or receive method directs to or from selected device, until
 552:../Generated_Code/I2C2.c **** **         a new slave device is selected by this method. This method
 553:../Generated_Code/I2C2.c **** **         is available for the MASTER mode.
 554:../Generated_Code/I2C2.c **** **     Parameters  :
 555:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 556:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 557:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 558:../Generated_Code/I2C2.c **** **         AddrType        - Specify type of slave address
 559:../Generated_Code/I2C2.c **** **                           (7bit, 10bit or general call address), e.g.
 560:../Generated_Code/I2C2.c **** **                           LDD_I2C_ADDRTYPE_7BITS.
 561:../Generated_Code/I2C2.c **** **         Addr            - 7bit or 10bit slave address value.
 562:../Generated_Code/I2C2.c **** **     Returns     :
 563:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 564:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 565:../Generated_Code/I2C2.c **** **                           ERR_BUSY - The device is busy, wait until
 566:../Generated_Code/I2C2.c **** **                           the current operation is finished.
 567:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  The device is disabled.
 568:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 569:../Generated_Code/I2C2.c **** **                           the active clock configuration
 570:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS_TYPE -  Invalid address
 571:../Generated_Code/I2C2.c **** **                           type.
 572:../Generated_Code/I2C2.c **** **                           ERR_PARAM_ADDRESS -  Invalid address value.
 573:../Generated_Code/I2C2.c **** ** ===================================================================
 574:../Generated_Code/I2C2.c **** */
 575:../Generated_Code/I2C2.c **** LDD_TError I2C2_SelectSlaveDevice(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TAddrType AddrType, LDD_I
 576:../Generated_Code/I2C2.c **** {
 1274              		.loc 1 576 0
 1275              		.cfi_startproc
 1276              		@ args = 0, pretend = 0, frame = 16
 1277              		@ frame_needed = 1, uses_anonymous_args = 0
 1278              		@ link register save eliminated.
 1279 0000 80B4     		push	{r7}
 1280              	.LCFI15:
 1281              		.cfi_def_cfa_offset 4
 1282              		.cfi_offset 7, -4
 1283 0002 85B0     		sub	sp, sp, #20
 1284              	.LCFI16:
 1285              		.cfi_def_cfa_offset 24
 1286 0004 00AF     		add	r7, sp, #0
 1287              	.LCFI17:
 1288              		.cfi_def_cfa_register 7
 1289 0006 7860     		str	r0, [r7, #4]
 1290 0008 1346     		mov	r3, r2
 1291 000a 0A46     		mov	r2, r1
 1292 000c FA70     		strb	r2, [r7, #3]
 1293 000e 3B80     		strh	r3, [r7, #0]	@ movhi
 577:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1294              		.loc 1 577 0
 1295 0010 7B68     		ldr	r3, [r7, #4]
 1296 0012 FB60     		str	r3, [r7, #12]
 578:../Generated_Code/I2C2.c **** 
 579:../Generated_Code/I2C2.c ****   if ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) { /* Is the device in the active state
 1297              		.loc 1 579 0
 1298 0014 FB68     		ldr	r3, [r7, #12]
 1299 0016 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1300 0018 03F00103 		and	r3, r3, #1
 1301 001c DBB2     		uxtb	r3, r3
 1302 001e 002B     		cmp	r3, #0
 1303 0020 02D0     		beq	.L48
 580:../Generated_Code/I2C2.c ****     return ERR_BUSY;                   /* If yes then error */
 1304              		.loc 1 580 0
 1305 0022 4FF00803 		mov	r3, #8
 1306 0026 66E0     		b	.L49
 1307              	.L48:
 581:../Generated_Code/I2C2.c ****   }
 582:../Generated_Code/I2C2.c ****   switch (AddrType) {
 1308              		.loc 1 582 0
 1309 0028 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1310 002a 012B     		cmp	r3, #1
 1311 002c 1FD0     		beq	.L52
 1312 002e 022B     		cmp	r3, #2
 1313 0030 4DD0     		beq	.L53
 1314 0032 002B     		cmp	r3, #0
 1315 0034 5AD1     		bne	.L57
 1316              	.L51:
 583:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_7BITS:
 584:../Generated_Code/I2C2.c ****       if (Addr > 0x7FU) {              /* Test address value */
 1317              		.loc 1 584 0
 1318 0036 3B88     		ldrh	r3, [r7, #0]
 1319 0038 7F2B     		cmp	r3, #127
 1320 003a 02D9     		bls	.L54
 585:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1321              		.loc 1 585 0
 1322 003c 4FF08903 		mov	r3, #137
 1323 0040 59E0     		b	.L49
 1324              	.L54:
 586:../Generated_Code/I2C2.c ****       }
 587:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)((uint8_t)Addr << 0x01U); /* Set slave address */
 1325              		.loc 1 587 0
 1326 0042 3B88     		ldrh	r3, [r7, #0]	@ movhi
 1327 0044 DBB2     		uxtb	r3, r3
 1328 0046 4FEA4303 		lsl	r3, r3, #1
 1329 004a DAB2     		uxtb	r2, r3
 1330 004c FB68     		ldr	r3, [r7, #12]
 1331 004e 1A71     		strb	r2, [r3, #4]
 588:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_10); /* Clear the general call flag 
 1332              		.loc 1 588 0
 1333 0050 FB68     		ldr	r3, [r7, #12]
 1334 0052 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1335 0054 23F01803 		bic	r3, r3, #24
 1336 0058 DAB2     		uxtb	r2, r3
 1337 005a FB68     		ldr	r3, [r7, #12]
 1338 005c 1A70     		strb	r2, [r3, #0]
 589:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_7; /* Set 7-bit address mode flag */
 1339              		.loc 1 589 0
 1340 005e FB68     		ldr	r3, [r7, #12]
 1341 0060 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1342 0062 43F02003 		orr	r3, r3, #32
 1343 0066 DAB2     		uxtb	r2, r3
 1344 0068 FB68     		ldr	r3, [r7, #12]
 1345 006a 1A70     		strb	r2, [r3, #0]
 590:../Generated_Code/I2C2.c ****     break;
 1346              		.loc 1 590 0
 1347 006c 41E0     		b	.L55
 1348              	.L52:
 591:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_10BITS:
 592:../Generated_Code/I2C2.c ****       if (Addr > 0x03FFU) {            /* Test address value */
 1349              		.loc 1 592 0
 1350 006e 3A88     		ldrh	r2, [r7, #0]
 1351 0070 40F2FF33 		movw	r3, #1023
 1352 0074 9A42     		cmp	r2, r3
 1353 0076 02D9     		bls	.L56
 593:../Generated_Code/I2C2.c ****         return ERR_PARAM_ADDRESS;      /* If value of address is invalid, return error */
 1354              		.loc 1 593 0
 1355 0078 4FF08903 		mov	r3, #137
 1356 007c 3BE0     		b	.L49
 1357              	.L56:
 594:../Generated_Code/I2C2.c ****       }
 595:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddr = (uint8_t)Addr; /* Set slave address - low byte */
 1358              		.loc 1 595 0
 1359 007e 3B88     		ldrh	r3, [r7, #0]	@ movhi
 1360 0080 DAB2     		uxtb	r2, r3
 1361 0082 FB68     		ldr	r3, [r7, #12]
 1362 0084 1A71     		strb	r2, [r3, #4]
 596:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh = (uint8_t)((uint16_t)Addr >> 0x07U); /* Set slave address - hig
 1363              		.loc 1 596 0
 1364 0086 3B88     		ldrh	r3, [r7, #0]
 1365 0088 4FEAD313 		lsr	r3, r3, #7
 1366 008c 9BB2     		uxth	r3, r3
 1367 008e DAB2     		uxtb	r2, r3
 1368 0090 FB68     		ldr	r3, [r7, #12]
 1369 0092 5A71     		strb	r2, [r3, #5]
 597:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh &= 0x06U; /* Format address to 11110xx0 */
 1370              		.loc 1 597 0
 1371 0094 FB68     		ldr	r3, [r7, #12]
 1372 0096 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1373 0098 03F00603 		and	r3, r3, #6
 1374 009c DAB2     		uxtb	r2, r3
 1375 009e FB68     		ldr	r3, [r7, #12]
 1376 00a0 5A71     		strb	r2, [r3, #5]
 598:../Generated_Code/I2C2.c ****       DeviceDataPrv->SlaveAddrHigh |= 0xF0U;
 1377              		.loc 1 598 0
 1378 00a2 FB68     		ldr	r3, [r7, #12]
 1379 00a4 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1380 00a6 63F00F03 		orn	r3, r3, #15
 1381 00aa DAB2     		uxtb	r2, r3
 1382 00ac FB68     		ldr	r3, [r7, #12]
 1383 00ae 5A71     		strb	r2, [r3, #5]
 599:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(GENERAL_CALL | ADDR_7); /* Clear the general call flag a
 1384              		.loc 1 599 0
 1385 00b0 FB68     		ldr	r3, [r7, #12]
 1386 00b2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1387 00b4 23F02803 		bic	r3, r3, #40
 1388 00b8 DAB2     		uxtb	r2, r3
 1389 00ba FB68     		ldr	r3, [r7, #12]
 1390 00bc 1A70     		strb	r2, [r3, #0]
 600:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= ADDR_10; /* Set 10-bit address mode flag */
 1391              		.loc 1 600 0
 1392 00be FB68     		ldr	r3, [r7, #12]
 1393 00c0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1394 00c2 43F01003 		orr	r3, r3, #16
 1395 00c6 DAB2     		uxtb	r2, r3
 1396 00c8 FB68     		ldr	r3, [r7, #12]
 1397 00ca 1A70     		strb	r2, [r3, #0]
 601:../Generated_Code/I2C2.c ****     break;
 1398              		.loc 1 601 0
 1399 00cc 11E0     		b	.L55
 1400              	.L53:
 602:../Generated_Code/I2C2.c ****     case LDD_I2C_ADDRTYPE_GENERAL_CALL:
 603:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(ADDR_7 | ADDR_10); /* Clear the 7-bit address flag and 1
 1401              		.loc 1 603 0
 1402 00ce FB68     		ldr	r3, [r7, #12]
 1403 00d0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1404 00d2 23F03003 		bic	r3, r3, #48
 1405 00d6 DAB2     		uxtb	r2, r3
 1406 00d8 FB68     		ldr	r3, [r7, #12]
 1407 00da 1A70     		strb	r2, [r3, #0]
 604:../Generated_Code/I2C2.c ****       DeviceDataPrv->SerFlag |= GENERAL_CALL; /* Set general call mode flag */
 1408              		.loc 1 604 0
 1409 00dc FB68     		ldr	r3, [r7, #12]
 1410 00de 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1411 00e0 43F00803 		orr	r3, r3, #8
 1412 00e4 DAB2     		uxtb	r2, r3
 1413 00e6 FB68     		ldr	r3, [r7, #12]
 1414 00e8 1A70     		strb	r2, [r3, #0]
 605:../Generated_Code/I2C2.c ****     break;
 1415              		.loc 1 605 0
 1416 00ea 02E0     		b	.L55
 1417              	.L57:
 606:../Generated_Code/I2C2.c ****     default:
 607:../Generated_Code/I2C2.c ****       return ERR_PARAM_ADDRESS_TYPE;   /* If value of address type is invalid, return error */
 1418              		.loc 1 607 0
 1419 00ec 4FF08D03 		mov	r3, #141
 1420 00f0 01E0     		b	.L49
 1421              	.L55:
 608:../Generated_Code/I2C2.c ****   }
 609:../Generated_Code/I2C2.c ****   return ERR_OK;                       /* OK */
 1422              		.loc 1 609 0
 1423 00f2 4FF00003 		mov	r3, #0
 1424              	.L49:
 610:../Generated_Code/I2C2.c **** }
 1425              		.loc 1 610 0
 1426 00f6 1846     		mov	r0, r3
 1427 00f8 07F11407 		add	r7, r7, #20
 1428 00fc BD46     		mov	sp, r7
 1429 00fe 80BC     		pop	{r7}
 1430 0100 7047     		bx	lr
 1431              		.cfi_endproc
 1432              	.LFE5:
 1434 0102 00BF     		.section	.text.I2C2_GetError,"ax",%progbits
 1435              		.align	2
 1436              		.global	I2C2_GetError
 1437              		.thumb
 1438              		.thumb_func
 1440              	I2C2_GetError:
 1441              	.LFB6:
 611:../Generated_Code/I2C2.c **** 
 612:../Generated_Code/I2C2.c **** /*
 613:../Generated_Code/I2C2.c **** ** ===================================================================
 614:../Generated_Code/I2C2.c **** **     Method      :  I2C2_GetError (component I2C_LDD)
 615:../Generated_Code/I2C2.c **** **
 616:../Generated_Code/I2C2.c **** **     Description :
 617:../Generated_Code/I2C2.c **** **         Returns value of error mask, e.g. LDD_I2C_ARBIT_LOST.
 618:../Generated_Code/I2C2.c **** **     Parameters  :
 619:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 620:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 621:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 622:../Generated_Code/I2C2.c **** **       * ErrorMaskPtr    - Pointer to a variable
 623:../Generated_Code/I2C2.c **** **                           where errors value mask will be stored.
 624:../Generated_Code/I2C2.c **** **     Returns     :
 625:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 626:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 627:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 628:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 629:../Generated_Code/I2C2.c **** **                           the active clock configuration
 630:../Generated_Code/I2C2.c **** ** ===================================================================
 631:../Generated_Code/I2C2.c **** */
 632:../Generated_Code/I2C2.c **** LDD_TError I2C2_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TErrorMask *ErrorMaskPtr)
 633:../Generated_Code/I2C2.c **** {
 1442              		.loc 1 633 0
 1443              		.cfi_startproc
 1444              		@ args = 0, pretend = 0, frame = 16
 1445              		@ frame_needed = 1, uses_anonymous_args = 0
 1446              		@ link register save eliminated.
 1447 0000 80B4     		push	{r7}
 1448              	.LCFI18:
 1449              		.cfi_def_cfa_offset 4
 1450              		.cfi_offset 7, -4
 1451 0002 85B0     		sub	sp, sp, #20
 1452              	.LCFI19:
 1453              		.cfi_def_cfa_offset 24
 1454 0004 00AF     		add	r7, sp, #0
 1455              	.LCFI20:
 1456              		.cfi_def_cfa_register 7
 1457 0006 7860     		str	r0, [r7, #4]
 1458 0008 3960     		str	r1, [r7, #0]
 634:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1459              		.loc 1 634 0
 1460 000a 7B68     		ldr	r3, [r7, #4]
 1461 000c FB60     		str	r3, [r7, #12]
 635:../Generated_Code/I2C2.c **** 
 636:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 637:../Generated_Code/I2C2.c ****   EnterCritical();
 1462              		.loc 1 637 0
 1463 000e 40F20003 		movw	r3, #:lower16:SR_lock
 1464 0012 C0F20003 		movt	r3, #:upper16:SR_lock
 1465 0016 1B78     		ldrb	r3, [r3, #0]
 1466 0018 DBB2     		uxtb	r3, r3
 1467 001a 03F10103 		add	r3, r3, #1
 1468 001e DBB2     		uxtb	r3, r3
 1469 0020 1A46     		mov	r2, r3
 1470 0022 40F20003 		movw	r3, #:lower16:SR_lock
 1471 0026 C0F20003 		movt	r3, #:upper16:SR_lock
 1472 002a 1146     		mov	r1, r2
 1473 002c 1970     		strb	r1, [r3, #0]
 1474 002e 012A     		cmp	r2, #1
 1475 0030 07D1     		bne	.L59
 1476              		.loc 1 637 0 is_stmt 0 discriminator 1
 1477 0032 40F20003 		movw	r3, #:lower16:SR_reg
 1478 0036 C0F20003 		movt	r3, #:upper16:SR_reg
 1479              	@ 637 "../Generated_Code/I2C2.c" 1
 1480 003a EFF31380 		MRS R0, FAULTMASK
 1481 003e 71B6     		CPSID f
 1482 0040 1870     		STRB R0, [r3, #0]
 1483              	@ 0 "" 2
 1484              		.thumb
 1485              	.L59:
 638:../Generated_Code/I2C2.c ****   *ErrorMaskPtr = DeviceDataPrv->ErrorMask; /* Return last value of error mask */
 1486              		.loc 1 638 0 is_stmt 1
 1487 0042 FB68     		ldr	r3, [r7, #12]
 1488 0044 5A88     		ldrh	r2, [r3, #2]
 1489 0046 3B68     		ldr	r3, [r7, #0]
 1490 0048 1A80     		strh	r2, [r3, #0]	@ movhi
 639:../Generated_Code/I2C2.c ****   DeviceDataPrv->ErrorMask = 0x00U;
 1491              		.loc 1 639 0
 1492 004a FB68     		ldr	r3, [r7, #12]
 1493 004c 4FF00002 		mov	r2, #0
 1494 0050 5A80     		strh	r2, [r3, #2]	@ movhi
 640:../Generated_Code/I2C2.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 641:../Generated_Code/I2C2.c ****   ExitCritical();
 1495              		.loc 1 641 0
 1496 0052 40F20003 		movw	r3, #:lower16:SR_lock
 1497 0056 C0F20003 		movt	r3, #:upper16:SR_lock
 1498 005a 1B78     		ldrb	r3, [r3, #0]
 1499 005c DBB2     		uxtb	r3, r3
 1500 005e 03F1FF33 		add	r3, r3, #-1
 1501 0062 DBB2     		uxtb	r3, r3
 1502 0064 1A46     		mov	r2, r3
 1503 0066 40F20003 		movw	r3, #:lower16:SR_lock
 1504 006a C0F20003 		movt	r3, #:upper16:SR_lock
 1505 006e 1146     		mov	r1, r2
 1506 0070 1970     		strb	r1, [r3, #0]
 1507 0072 002A     		cmp	r2, #0
 1508 0074 06D1     		bne	.L60
 1509              		.loc 1 641 0 is_stmt 0 discriminator 1
 1510 0076 40F20003 		movw	r3, #:lower16:SR_reg
 1511 007a C0F20003 		movt	r3, #:upper16:SR_reg
 1512              	@ 641 "../Generated_Code/I2C2.c" 1
 1513 007e 1878     		ldrb r0, [r3, #0]
 1514 0080 80F31388 		msr FAULTMASK,r0;
 1515              		
 1516              	@ 0 "" 2
 1517              		.thumb
 1518              	.L60:
 642:../Generated_Code/I2C2.c ****   return ERR_OK;
 1519              		.loc 1 642 0 is_stmt 1
 1520 0084 4FF00003 		mov	r3, #0
 643:../Generated_Code/I2C2.c **** }
 1521              		.loc 1 643 0
 1522 0088 1846     		mov	r0, r3
 1523 008a 07F11407 		add	r7, r7, #20
 1524 008e BD46     		mov	sp, r7
 1525 0090 80BC     		pop	{r7}
 1526 0092 7047     		bx	lr
 1527              		.cfi_endproc
 1528              	.LFE6:
 1530              		.section	.text.I2C2_CheckBus,"ax",%progbits
 1531              		.align	2
 1532              		.global	I2C2_CheckBus
 1533              		.thumb
 1534              		.thumb_func
 1536              	I2C2_CheckBus:
 1537              	.LFB7:
 644:../Generated_Code/I2C2.c **** 
 645:../Generated_Code/I2C2.c **** /*
 646:../Generated_Code/I2C2.c **** ** ===================================================================
 647:../Generated_Code/I2C2.c **** **     Method      :  I2C2_CheckBus (component I2C_LDD)
 648:../Generated_Code/I2C2.c **** **
 649:../Generated_Code/I2C2.c **** **     Description :
 650:../Generated_Code/I2C2.c **** **         This method returns the status of the bus. If the START
 651:../Generated_Code/I2C2.c **** **         condition has been detected, the method returns LDD_I2C_BUSY.
 652:../Generated_Code/I2C2.c **** **         If the STOP condition has been detected, the method returns
 653:../Generated_Code/I2C2.c **** **         LDD_I2C_IDLE.
 654:../Generated_Code/I2C2.c **** **     Parameters  :
 655:../Generated_Code/I2C2.c **** **         NAME            - DESCRIPTION
 656:../Generated_Code/I2C2.c **** **       * DeviceDataPtr   - Device data structure
 657:../Generated_Code/I2C2.c **** **                           pointer returned by <Init> method.
 658:../Generated_Code/I2C2.c **** **       * BusStatePtr     - Pointer to a variable,
 659:../Generated_Code/I2C2.c **** **                           where value of status is stored.
 660:../Generated_Code/I2C2.c **** **     Returns     :
 661:../Generated_Code/I2C2.c **** **         ---             - Error code, possible codes:
 662:../Generated_Code/I2C2.c **** **                           ERR_OK - OK
 663:../Generated_Code/I2C2.c **** **                           ERR_DISABLED -  Device is disabled
 664:../Generated_Code/I2C2.c **** **                           ERR_SPEED - This device does not work in
 665:../Generated_Code/I2C2.c **** **                           the active clock configuration
 666:../Generated_Code/I2C2.c **** ** ===================================================================
 667:../Generated_Code/I2C2.c **** */
 668:../Generated_Code/I2C2.c **** LDD_TError I2C2_CheckBus(LDD_TDeviceData *DeviceDataPtr, LDD_I2C_TBusState *BusStatePtr)
 669:../Generated_Code/I2C2.c **** {
 1538              		.loc 1 669 0
 1539              		.cfi_startproc
 1540              		@ args = 0, pretend = 0, frame = 16
 1541              		@ frame_needed = 1, uses_anonymous_args = 0
 1542              		@ link register save eliminated.
 1543 0000 80B4     		push	{r7}
 1544              	.LCFI21:
 1545              		.cfi_def_cfa_offset 4
 1546              		.cfi_offset 7, -4
 1547 0002 85B0     		sub	sp, sp, #20
 1548              	.LCFI22:
 1549              		.cfi_def_cfa_offset 24
 1550 0004 00AF     		add	r7, sp, #0
 1551              	.LCFI23:
 1552              		.cfi_def_cfa_register 7
 1553 0006 7860     		str	r0, [r7, #4]
 1554 0008 3960     		str	r1, [r7, #0]
 670:../Generated_Code/I2C2.c ****   I2C2_TDeviceData *DeviceDataPrv = (I2C2_TDeviceData *)DeviceDataPtr;
 1555              		.loc 1 670 0
 1556 000a 7B68     		ldr	r3, [r7, #4]
 1557 000c FB60     		str	r3, [r7, #12]
 671:../Generated_Code/I2C2.c **** 
 672:../Generated_Code/I2C2.c ****   (void)DeviceDataPrv;                 /* Suppress unused variable warning if needed */
 673:../Generated_Code/I2C2.c ****   *BusStatePtr = (LDD_I2C_TBusState)((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY)?LDD_
 1558              		.loc 1 673 0
 1559 000e 4FF4E043 		mov	r3, #28672
 1560 0012 C4F20603 		movt	r3, 16390
 1561 0016 DB78     		ldrb	r3, [r3, #3]
 1562 0018 DBB2     		uxtb	r3, r3
 1563 001a 03F02003 		and	r3, r3, #32
 1564 001e 002B     		cmp	r3, #0
 1565 0020 02D1     		bne	.L62
 1566              		.loc 1 673 0 is_stmt 0 discriminator 1
 1567 0022 4FF00103 		mov	r3, #1
 1568 0026 01E0     		b	.L63
 1569              	.L62:
 1570              		.loc 1 673 0 discriminator 2
 1571 0028 4FF00003 		mov	r3, #0
 1572              	.L63:
 1573              		.loc 1 673 0 discriminator 3
 1574 002c 3A68     		ldr	r2, [r7, #0]
 1575 002e 1370     		strb	r3, [r2, #0]
 674:../Generated_Code/I2C2.c ****   return ERR_OK;
 1576              		.loc 1 674 0 is_stmt 1 discriminator 3
 1577 0030 4FF00003 		mov	r3, #0
 675:../Generated_Code/I2C2.c **** }
 1578              		.loc 1 675 0 discriminator 3
 1579 0034 1846     		mov	r0, r3
 1580 0036 07F11407 		add	r7, r7, #20
 1581 003a BD46     		mov	sp, r7
 1582 003c 80BC     		pop	{r7}
 1583 003e 7047     		bx	lr
 1584              		.cfi_endproc
 1585              	.LFE7:
 1587              		.text
 1588              	.Letext0:
 1589              		.file 2 "C:/Freescale/CW MCU v10.3_NOBETA/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1590              		.file 3 "C:/workspaceBakalarkaa/Pex/Generated_Code/IO_Map.h"
 1591              		.file 4 "C:/workspaceBakalarkaa/Pex/Generated_Code/PE_LDD.h"
 1592              		.file 5 "C:/workspaceBakalarkaa/Pex/Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 I2C2.c
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:19     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:22     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:25     .bss.INT_I2C1__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:28     .bss.INT_I2C1__DEFAULT_RTOS_ISRPARAM:00000000 INT_I2C1__DEFAULT_RTOS_ISRPARAM
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:31     .text.I2C2_Interrupt:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:36     .text.I2C2_Interrupt:00000000 I2C2_Interrupt
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:473    .text.I2C2_Init:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:478    .text.I2C2_Init:00000000 I2C2_Init
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:667    .text.I2C2_Deinit:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:672    .text.I2C2_Deinit:00000000 I2C2_Deinit
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:721    .text.I2C2_MasterSendBlock:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:726    .text.I2C2_MasterSendBlock:00000000 I2C2_MasterSendBlock
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:994    .text.I2C2_MasterReceiveBlock:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:999    .text.I2C2_MasterReceiveBlock:00000000 I2C2_MasterReceiveBlock
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:1267   .text.I2C2_SelectSlaveDevice:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:1272   .text.I2C2_SelectSlaveDevice:00000000 I2C2_SelectSlaveDevice
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:1435   .text.I2C2_GetError:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:1440   .text.I2C2_GetError:00000000 I2C2_GetError
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:1531   .text.I2C2_CheckBus:00000000 $t
C:\Users\x\AppData\Local\Temp\ccAqEogh.s:1536   .text.I2C2_CheckBus:00000000 I2C2_CheckBus
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
I2C2_OnMasterBlockSent
I2C2_OnMasterBlockReceived
I2C2_OnError
PE_LDD_DeviceDataList
SR_lock
SR_reg
