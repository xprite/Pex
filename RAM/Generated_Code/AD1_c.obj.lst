   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"AD1.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata.ChannelToPin,"a",%progbits
  19              		.align	2
  22              	ChannelToPin:
  23 0000 4D       		.byte	77
  24 0001 000000   		.section	.rodata.StaticSampleGroups,"a",%progbits
  25              		.align	2
  28              	StaticSampleGroups:
  29 0000 01       		.byte	1
  30 0001 4D       		.byte	77
  31 0002 0000     		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  32              		.align	2
  35              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  36 0000 00000000 		.space	8
  36      00000000 
  37              		.section	.bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  38              		.align	2
  41              	INT_ADC0__DEFAULT_RTOS_ISRPARAM:
  42 0000 00000000 		.space	4
  43              		.section	.text.AD1_Init,"ax",%progbits
  44              		.align	2
  45              		.global	AD1_Init
  46              		.thumb
  47              		.thumb_func
  49              	AD1_Init:
  50              	.LFB0:
  51              		.file 1 "../Generated_Code/AD1.c"
   1:../Generated_Code/AD1.c **** /** ###################################################################
   2:../Generated_Code/AD1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AD1.c **** **     Filename    : AD1.c
   4:../Generated_Code/AD1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AD1.c **** **     Processor   : MK40DX256ZVLQ10
   6:../Generated_Code/AD1.c **** **     Component   : ADC_LDD
   7:../Generated_Code/AD1.c **** **     Version     : Component 01.115, Driver 01.07, CPU db: 3.00.001
   8:../Generated_Code/AD1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AD1.c **** **     Date/Time   : 2013-04-11, 15:40, # CodeGen: 91
  10:../Generated_Code/AD1.c **** **     Abstract    :
  11:../Generated_Code/AD1.c **** **         This device "ADC_LDD" implements an A/D converter,
  12:../Generated_Code/AD1.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/AD1.c **** **     Settings    :
  14:../Generated_Code/AD1.c **** **          Component name                                 : AD1
  15:../Generated_Code/AD1.c **** **          A/D converter                                  : ADC0
  16:../Generated_Code/AD1.c **** **          Discontinuous mode                             : no
  17:../Generated_Code/AD1.c **** **          Converter mode                                 : Sequential
  18:../Generated_Code/AD1.c **** **          Interrupt service/event                        : Enabled
  19:../Generated_Code/AD1.c **** **            A/D interrupt                                : INT_ADC0
  20:../Generated_Code/AD1.c **** **            A/D interrupt priority                       : 3
  21:../Generated_Code/AD1.c **** **          A/D channel list                               : 1
  22:../Generated_Code/AD1.c **** **            Channel 0                                    : 
  23:../Generated_Code/AD1.c **** **              Channel mode                               : Single Ended
  24:../Generated_Code/AD1.c **** **                Input                                    : 
  25:../Generated_Code/AD1.c **** **                  A/D channel (pin)                      : PTB3/I2C0_SDA/UART0_CTS_b/FTM0_FLT0/LC
  26:../Generated_Code/AD1.c **** **                  A/D channel (pin) signal               : 
  27:../Generated_Code/AD1.c **** **          Static sample groups                           : Enabled
  28:../Generated_Code/AD1.c **** **            Sample group list                            : 1
  29:../Generated_Code/AD1.c **** **              Group 0                                    : 
  30:../Generated_Code/AD1.c **** **                Sample list                              : 1
  31:../Generated_Code/AD1.c **** **                  Sample 0                               : Enabled
  32:../Generated_Code/AD1.c **** **                    Channel index                        : 0
  33:../Generated_Code/AD1.c **** **          A/D resolution                                 : 8 bits
  34:../Generated_Code/AD1.c **** **          Low-power mode                                 : Disabled
  35:../Generated_Code/AD1.c **** **          High-speed conversion mode                     : Disabled
  36:../Generated_Code/AD1.c **** **          Asynchro clock output                          : Disabled
  37:../Generated_Code/AD1.c **** **          Sample time                                    : 4 clock periods
  38:../Generated_Code/AD1.c **** **          Number of conversions                          : 1
  39:../Generated_Code/AD1.c **** **          Conversion time                                : 4.25 µs
  40:../Generated_Code/AD1.c **** **          ADC clock                                      : 4 MHz (250 ns)
  41:../Generated_Code/AD1.c **** **          Single conversion time - Single-ended          : 5.604 us
  42:../Generated_Code/AD1.c **** **          Single conversion time - Differential          : 8.104 us
  43:../Generated_Code/AD1.c **** **          Additional conversion time - Single-ended      : 4.25 us
  44:../Generated_Code/AD1.c **** **          Additional conversion time - Differential      : 6.75 us
  45:../Generated_Code/AD1.c **** **          Result type                                    : unsigned 8 bits, right justified
  46:../Generated_Code/AD1.c **** **          Trigger                                        : Enabled
  47:../Generated_Code/AD1.c **** **            Trigger signal list                          : 1
  48:../Generated_Code/AD1.c **** **              Trigger signal 0                           : Enabled
  49:../Generated_Code/AD1.c **** **                Trigger input                            : Flex_timer_1
  50:../Generated_Code/AD1.c **** **                Trigger input signal                     : 
  51:../Generated_Code/AD1.c **** **                Trigger type                             : Internal
  52:../Generated_Code/AD1.c **** **                  Source component                       : CameraTimer
  53:../Generated_Code/AD1.c **** **            Trigger active state                         : Rising edge
  54:../Generated_Code/AD1.c **** **          Voltage reference                              : 
  55:../Generated_Code/AD1.c **** **            High voltage reference                       : 
  56:../Generated_Code/AD1.c **** **              Volt. ref. pin                             : VREFH
  57:../Generated_Code/AD1.c **** **              Volt. ref pin signal                       : 
  58:../Generated_Code/AD1.c **** **            Low voltage reference                        : 
  59:../Generated_Code/AD1.c **** **              Volt. ref. pin                             : VREFL
  60:../Generated_Code/AD1.c **** **              Volt. ref pin signal                       : 
  61:../Generated_Code/AD1.c **** **          Initialization                                 : 
  62:../Generated_Code/AD1.c **** **            Enabled in init. code                        : yes
  63:../Generated_Code/AD1.c **** **            Auto initialization                          : yes
  64:../Generated_Code/AD1.c **** **            Event mask                                   : 
  65:../Generated_Code/AD1.c **** **              OnMeasurementComplete                      : Enabled
  66:../Generated_Code/AD1.c **** **          CPU clock/configuration selection              : 
  67:../Generated_Code/AD1.c **** **            Clock configuration 0                        : This component enabled
  68:../Generated_Code/AD1.c **** **            Clock configuration 1                        : This component disabled
  69:../Generated_Code/AD1.c **** **            Clock configuration 2                        : This component disabled
  70:../Generated_Code/AD1.c **** **            Clock configuration 3                        : This component disabled
  71:../Generated_Code/AD1.c **** **            Clock configuration 4                        : This component disabled
  72:../Generated_Code/AD1.c **** **            Clock configuration 5                        : This component disabled
  73:../Generated_Code/AD1.c **** **            Clock configuration 6                        : This component disabled
  74:../Generated_Code/AD1.c **** **            Clock configuration 7                        : This component disabled
  75:../Generated_Code/AD1.c **** **     Contents    :
  76:../Generated_Code/AD1.c **** **         Init                          - LDD_TDeviceData* AD1_Init(LDD_TUserData *UserDataPtr);
  77:../Generated_Code/AD1.c **** **         Deinit                        - void AD1_Deinit(LDD_TDeviceData *DeviceDataPtr);
  78:../Generated_Code/AD1.c **** **         StartSingleMeasurement        - LDD_TError AD1_StartSingleMeasurement(LDD_TDeviceData *D
  79:../Generated_Code/AD1.c **** **         StartLoopMeasurement          - LDD_TError AD1_StartLoopMeasurement(LDD_TDeviceData *Dev
  80:../Generated_Code/AD1.c **** **         StartLoopTriggeredMeasurement - LDD_TError AD1_StartLoopTriggeredMeasurement(LDD_TDevice
  81:../Generated_Code/AD1.c **** **         SelectSampleGroup             - LDD_TError AD1_SelectSampleGroup(LDD_TDeviceData *Device
  82:../Generated_Code/AD1.c **** **         CreateSampleGroup             - LDD_TError AD1_CreateSampleGroup(LDD_TDeviceData *Device
  83:../Generated_Code/AD1.c **** **         GetMeasuredValues             - LDD_TError AD1_GetMeasuredValues(LDD_TDeviceData *Device
  84:../Generated_Code/AD1.c **** **
  85:../Generated_Code/AD1.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  86:../Generated_Code/AD1.c **** **     
  87:../Generated_Code/AD1.c **** **     http      : www.freescale.com
  88:../Generated_Code/AD1.c **** **     mail      : support@freescale.com
  89:../Generated_Code/AD1.c **** ** ###################################################################*/
  90:../Generated_Code/AD1.c **** 
  91:../Generated_Code/AD1.c **** /* MODULE AD1. */
  92:../Generated_Code/AD1.c **** 
  93:../Generated_Code/AD1.c **** #include "Events.h"
  94:../Generated_Code/AD1.c **** #include "AD1.h"
  95:../Generated_Code/AD1.c **** /* {Default RTOS Adapter} No RTOS includes */
  96:../Generated_Code/AD1.c **** 
  97:../Generated_Code/AD1.c **** #define AD1_AVAILABLE_CHANNEL0_31_PIN_MASK (LDD_ADC_CHANNEL_0_PIN) /* Mask of all allocated channel
  98:../Generated_Code/AD1.c **** #define AD1_AVAILABLE_CHANNEL32_63_PIN_MASK 0x00U /* Mask of all allocated channel pins from 32 to 
  99:../Generated_Code/AD1.c **** #define AD1_AVAILABLE_TRIGGER_PIN_MASK (LDD_ADC_TRIGGER_0_PIN) /* Mask of all allocated trigger pin
 100:../Generated_Code/AD1.c **** #define AD1_AVAILABLE_VOLT_REF_PIN_MASK (LDD_ADC_LOW_VOLT_REF_PIN | LDD_ADC_HIGH_VOLT_REF_PIN) /* M
 101:../Generated_Code/AD1.c **** 
 102:../Generated_Code/AD1.c **** static const uint8_t ChannelToPin[] = { /* Channel to pin conversion table */
 103:../Generated_Code/AD1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 104:../Generated_Code/AD1.c ****   0x4DU                                /* Status and control register value */
 105:../Generated_Code/AD1.c **** };
 106:../Generated_Code/AD1.c **** 
 107:../Generated_Code/AD1.c **** typedef struct {
 108:../Generated_Code/AD1.c ****   uint8_t  SampleCount;                /* Sample count */
 109:../Generated_Code/AD1.c ****   uint8_t  StatusControlRegVal[AD1_MAX_HW_SAMPLE_COUNT]; /* Status and control register values */
 110:../Generated_Code/AD1.c **** } TStaticSampleGroup;
 111:../Generated_Code/AD1.c **** 
 112:../Generated_Code/AD1.c **** static const TStaticSampleGroup StaticSampleGroups[AD1_STATIC_GROUP_COUNT] = {
 113:../Generated_Code/AD1.c ****   { /* Static sample group 0 */
 114:../Generated_Code/AD1.c ****     1U,                                /* Sample count */
 115:../Generated_Code/AD1.c ****     {
 116:../Generated_Code/AD1.c ****       /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 117:../Generated_Code/AD1.c ****       0x4DU
 118:../Generated_Code/AD1.c ****     }                                  /* Samples settings */
 119:../Generated_Code/AD1.c ****   }
 120:../Generated_Code/AD1.c **** };
 121:../Generated_Code/AD1.c **** 
 122:../Generated_Code/AD1.c **** typedef struct {
 123:../Generated_Code/AD1.c ****   uint8_t SampleCount;                 /* Number of samples in the last selected/created sample gro
 124:../Generated_Code/AD1.c ****   uint8_t FirstSample;                 /* First sample of group store */
 125:../Generated_Code/AD1.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 126:../Generated_Code/AD1.c **** } AD1_TDeviceData;                     /* Device data structure type */
 127:../Generated_Code/AD1.c **** 
 128:../Generated_Code/AD1.c **** typedef AD1_TDeviceData* AD1_TDeviceDataPtr ; /* Pointer to the device data structure. */
 129:../Generated_Code/AD1.c **** 
 130:../Generated_Code/AD1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 131:../Generated_Code/AD1.c **** static AD1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 132:../Generated_Code/AD1.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 133:../Generated_Code/AD1.c **** static AD1_TDeviceDataPtr INT_ADC0__DEFAULT_RTOS_ISRPARAM;
 134:../Generated_Code/AD1.c **** /*
 135:../Generated_Code/AD1.c **** ** ===================================================================
 136:../Generated_Code/AD1.c **** **     Method      :  AD1_Init (component ADC_LDD)
 137:../Generated_Code/AD1.c **** **
 138:../Generated_Code/AD1.c **** **     Description :
 139:../Generated_Code/AD1.c **** **         Initializes the device. Allocates memory for the device data
 140:../Generated_Code/AD1.c **** **         structure, allocates interrupt vectors and sets interrupt
 141:../Generated_Code/AD1.c **** **         priority, sets pin routing, sets timing, etc.
 142:../Generated_Code/AD1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 143:../Generated_Code/AD1.c **** **         device is also enabled(see the description of the Enable()
 144:../Generated_Code/AD1.c **** **         method). In this case the Enable() method is not necessary
 145:../Generated_Code/AD1.c **** **         and needn't to be generated. 
 146:../Generated_Code/AD1.c **** **         This method can be called only once. Before the second call
 147:../Generated_Code/AD1.c **** **         of Init() the Deinit() must be called first.
 148:../Generated_Code/AD1.c **** **     Parameters  :
 149:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 150:../Generated_Code/AD1.c **** **       * UserDataPtr     - Pointer to the user or
 151:../Generated_Code/AD1.c **** **                           RTOS specific data. This pointer will be
 152:../Generated_Code/AD1.c **** **                           passed as an event or callback parameter.
 153:../Generated_Code/AD1.c **** **     Returns     :
 154:../Generated_Code/AD1.c **** **         ---             - Device data structure pointer.
 155:../Generated_Code/AD1.c **** ** ===================================================================
 156:../Generated_Code/AD1.c **** */
 157:../Generated_Code/AD1.c **** LDD_TDeviceData* AD1_Init(LDD_TUserData *UserDataPtr)
 158:../Generated_Code/AD1.c **** {
  52              		.loc 1 158 0
  53              		.cfi_startproc
  54              		@ args = 0, pretend = 0, frame = 16
  55              		@ frame_needed = 1, uses_anonymous_args = 0
  56              		@ link register save eliminated.
  57 0000 80B4     		push	{r7}
  58              	.LCFI0:
  59              		.cfi_def_cfa_offset 4
  60              		.cfi_offset 7, -4
  61 0002 85B0     		sub	sp, sp, #20
  62              	.LCFI1:
  63              		.cfi_def_cfa_offset 24
  64 0004 00AF     		add	r7, sp, #0
  65              	.LCFI2:
  66              		.cfi_def_cfa_register 7
  67 0006 7860     		str	r0, [r7, #4]
 159:../Generated_Code/AD1.c ****   /* Allocate LDD device structure */
 160:../Generated_Code/AD1.c ****   AD1_TDeviceDataPtr DeviceDataPrv;
 161:../Generated_Code/AD1.c **** 
 162:../Generated_Code/AD1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 163:../Generated_Code/AD1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  68              		.loc 1 163 0
  69 0008 40F20003 		movw	r3, #:lower16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  70 000c C0F20003 		movt	r3, #:upper16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  71 0010 FB60     		str	r3, [r7, #12]
 164:../Generated_Code/AD1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  72              		.loc 1 164 0
  73 0012 FB68     		ldr	r3, [r7, #12]
  74 0014 7A68     		ldr	r2, [r7, #4]
  75 0016 5A60     		str	r2, [r3, #4]
 165:../Generated_Code/AD1.c ****   /* Interrupt vector(s) allocation */
 166:../Generated_Code/AD1.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 167:../Generated_Code/AD1.c ****   INT_ADC0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  76              		.loc 1 167 0
  77 0018 40F20003 		movw	r3, #:lower16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
  78 001c C0F20003 		movt	r3, #:upper16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
  79 0020 FA68     		ldr	r2, [r7, #12]
  80 0022 1A60     		str	r2, [r3, #0]
 168:../Generated_Code/AD1.c ****   DeviceDataPrv->SampleCount = 0U;     /* Initializing SampleCount for right access of some methods
  81              		.loc 1 168 0
  82 0024 FB68     		ldr	r3, [r7, #12]
  83 0026 4FF00002 		mov	r2, #0
  84 002a 1A70     		strb	r2, [r3, #0]
 169:../Generated_Code/AD1.c ****   /* SIM_SCGC6: ADC0=1 */
 170:../Generated_Code/AD1.c ****   SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;                                                   
  85              		.loc 1 170 0
  86 002c 4FF4E043 		mov	r3, #28672
  87 0030 C4F20403 		movt	r3, 16388
  88 0034 4FF4E042 		mov	r2, #28672
  89 0038 C4F20402 		movt	r2, 16388
  90 003c 02F58052 		add	r2, r2, #4096
  91 0040 02F13C02 		add	r2, r2, #60
  92 0044 1268     		ldr	r2, [r2, #0]
  93 0046 42F00062 		orr	r2, r2, #134217728
  94 004a 03F58053 		add	r3, r3, #4096
  95 004e 03F13C03 		add	r3, r3, #60
  96 0052 1A60     		str	r2, [r3, #0]
 171:../Generated_Code/AD1.c ****   /* Interrupt vector(s) priority setting */
 172:../Generated_Code/AD1.c ****   /* NVICIP57: PRI57=0x30 */
 173:../Generated_Code/AD1.c ****   NVICIP57 = NVIC_IP_PRI57(0x30);                                                   
  97              		.loc 1 173 0
  98 0054 4FF46143 		mov	r3, #57600
  99 0058 CEF20003 		movt	r3, 57344
 100 005c 4FF03002 		mov	r2, #48
 101 0060 83F83923 		strb	r2, [r3, #825]
 174:../Generated_Code/AD1.c ****   /* NVICISER1: SETENA|=0x02000000 */
 175:../Generated_Code/AD1.c ****   NVICISER1 |= NVIC_ISER_SETENA(0x02000000);                                                   
 102              		.loc 1 175 0
 103 0064 4FF46143 		mov	r3, #57600
 104 0068 CEF20003 		movt	r3, 57344
 105 006c 4FF46142 		mov	r2, #57600
 106 0070 CEF20002 		movt	r2, 57344
 107 0074 5268     		ldr	r2, [r2, #4]
 108 0076 42F00072 		orr	r2, r2, #33554432
 109 007a 5A60     		str	r2, [r3, #4]
 176:../Generated_Code/AD1.c ****   /* PORTB_PCR3: ISF=0,MUX=0 */
 177:../Generated_Code/AD1.c ****   PORTB_PCR3 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
 110              		.loc 1 177 0
 111 007c 4FF42043 		mov	r3, #40960
 112 0080 C4F20403 		movt	r3, 16388
 113 0084 4FF42042 		mov	r2, #40960
 114 0088 C4F20402 		movt	r2, 16388
 115 008c D268     		ldr	r2, [r2, #12]
 116 008e 22F08072 		bic	r2, r2, #16777216
 117 0092 22F4E062 		bic	r2, r2, #1792
 118 0096 DA60     		str	r2, [r3, #12]
 178:../Generated_Code/AD1.c ****   /* SIM_SOPT7: ADC0TRGSEL=9 */
 179:../Generated_Code/AD1.c ****   SIM_SOPT7 = (uint32_t)((SIM_SOPT7 & (uint32_t)~(uint32_t)(
 119              		.loc 1 179 0
 120 0098 4FF4E043 		mov	r3, #28672
 121 009c C4F20403 		movt	r3, 16388
 122 00a0 4FF4E042 		mov	r2, #28672
 123 00a4 C4F20402 		movt	r2, 16388
 124 00a8 02F58052 		add	r2, r2, #4096
 125 00ac 02F11802 		add	r2, r2, #24
 126 00b0 1268     		ldr	r2, [r2, #0]
 127 00b2 22F00F02 		bic	r2, r2, #15
 128 00b6 42F00902 		orr	r2, r2, #9
 129 00ba 03F58053 		add	r3, r3, #4096
 130 00be 03F11803 		add	r3, r3, #24
 131 00c2 1A60     		str	r2, [r3, #0]
 180:../Generated_Code/AD1.c ****                SIM_SOPT7_ADC0TRGSEL(0x06)
 181:../Generated_Code/AD1.c ****               )) | (uint32_t)(
 182:../Generated_Code/AD1.c ****                SIM_SOPT7_ADC0TRGSEL(0x09)
 183:../Generated_Code/AD1.c ****               ));                                                  
 184:../Generated_Code/AD1.c ****   /* SIM_SOPT7: ADC0PRETRGSEL=0 */
 185:../Generated_Code/AD1.c ****   SIM_SOPT7 &= (uint32_t)~(uint32_t)(SIM_SOPT7_ADC0PRETRGSEL_MASK);                                
 132              		.loc 1 185 0
 133 00c4 4FF4E043 		mov	r3, #28672
 134 00c8 C4F20403 		movt	r3, 16388
 135 00cc 4FF4E042 		mov	r2, #28672
 136 00d0 C4F20402 		movt	r2, 16388
 137 00d4 02F58052 		add	r2, r2, #4096
 138 00d8 02F11802 		add	r2, r2, #24
 139 00dc 1268     		ldr	r2, [r2, #0]
 140 00de 22F01002 		bic	r2, r2, #16
 141 00e2 03F58053 		add	r3, r3, #4096
 142 00e6 03F11803 		add	r3, r3, #24
 143 00ea 1A60     		str	r2, [r3, #0]
 186:../Generated_Code/AD1.c ****   /* SIM_SOPT7: ADC0ALTTRGEN=1 */
 187:../Generated_Code/AD1.c ****   SIM_SOPT7 |= SIM_SOPT7_ADC0ALTTRGEN_MASK;                                                   
 144              		.loc 1 187 0
 145 00ec 4FF4E043 		mov	r3, #28672
 146 00f0 C4F20403 		movt	r3, 16388
 147 00f4 4FF4E042 		mov	r2, #28672
 148 00f8 C4F20402 		movt	r2, 16388
 149 00fc 02F58052 		add	r2, r2, #4096
 150 0100 02F11802 		add	r2, r2, #24
 151 0104 1268     		ldr	r2, [r2, #0]
 152 0106 42F08002 		orr	r2, r2, #128
 153 010a 03F58053 		add	r3, r3, #4096
 154 010e 03F11803 		add	r3, r3, #24
 155 0112 1A60     		str	r2, [r3, #0]
 188:../Generated_Code/AD1.c ****   /* ADC0_CFG1: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 189:../Generated_Code/AD1.c ****   ADC0_CFG1 = ADC_CFG1_ADICLK(0x02);                                                   
 156              		.loc 1 189 0
 157 0114 4FF43043 		mov	r3, #45056
 158 0118 C4F20303 		movt	r3, 16387
 159 011c 4FF00202 		mov	r2, #2
 160 0120 9A60     		str	r2, [r3, #8]
 190:../Generated_Code/AD1.c ****   /* ADC0_CFG2: ADACKEN=0,ADHSC=0,ADLSTS=0 */
 191:../Generated_Code/AD1.c ****   ADC0_CFG2 &= (uint32_t)~(uint32_t)(
 161              		.loc 1 191 0
 162 0122 4FF43043 		mov	r3, #45056
 163 0126 C4F20303 		movt	r3, 16387
 164 012a 4FF43042 		mov	r2, #45056
 165 012e C4F20302 		movt	r2, 16387
 166 0132 D268     		ldr	r2, [r2, #12]
 167 0134 22F00F02 		bic	r2, r2, #15
 168 0138 DA60     		str	r2, [r3, #12]
 192:../Generated_Code/AD1.c ****                 ADC_CFG2_ADACKEN_MASK |
 193:../Generated_Code/AD1.c ****                 ADC_CFG2_ADHSC_MASK |
 194:../Generated_Code/AD1.c ****                 ADC_CFG2_ADLSTS(0x03)
 195:../Generated_Code/AD1.c ****                );                                                   
 196:../Generated_Code/AD1.c ****   /* ADC0_SC2: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 197:../Generated_Code/AD1.c ****   ADC0_SC2 = 0x00U;                                                   
 169              		.loc 1 197 0
 170 013a 4FF43043 		mov	r3, #45056
 171 013e C4F20303 		movt	r3, 16387
 172 0142 4FF00002 		mov	r2, #0
 173 0146 1A62     		str	r2, [r3, #32]
 198:../Generated_Code/AD1.c ****   /* ADC0_SC3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 199:../Generated_Code/AD1.c ****   ADC0_SC3 = ADC_SC3_CALF_MASK;                                                   
 174              		.loc 1 199 0
 175 0148 4FF43043 		mov	r3, #45056
 176 014c C4F20303 		movt	r3, 16387
 177 0150 4FF04002 		mov	r2, #64
 178 0154 5A62     		str	r2, [r3, #36]
 200:../Generated_Code/AD1.c ****   /* Registration of the device structure */
 201:../Generated_Code/AD1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_AD1_ID,DeviceDataPrv);
 179              		.loc 1 201 0
 180 0156 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 181 015a C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 182 015e FA68     		ldr	r2, [r7, #12]
 183 0160 DA61     		str	r2, [r3, #28]
 202:../Generated_Code/AD1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 184              		.loc 1 202 0
 185 0162 FB68     		ldr	r3, [r7, #12]
 203:../Generated_Code/AD1.c **** }
 186              		.loc 1 203 0
 187 0164 1846     		mov	r0, r3
 188 0166 07F11407 		add	r7, r7, #20
 189 016a BD46     		mov	sp, r7
 190 016c 80BC     		pop	{r7}
 191 016e 7047     		bx	lr
 192              		.cfi_endproc
 193              	.LFE0:
 195              		.section	.text.AD1_Deinit,"ax",%progbits
 196              		.align	2
 197              		.global	AD1_Deinit
 198              		.thumb
 199              		.thumb_func
 201              	AD1_Deinit:
 202              	.LFB1:
 204:../Generated_Code/AD1.c **** 
 205:../Generated_Code/AD1.c **** /*
 206:../Generated_Code/AD1.c **** ** ===================================================================
 207:../Generated_Code/AD1.c **** **     Method      :  AD1_Deinit (component ADC_LDD)
 208:../Generated_Code/AD1.c **** **
 209:../Generated_Code/AD1.c **** **     Description :
 210:../Generated_Code/AD1.c **** **         Deinitializes the device. Switches off the device, frees the
 211:../Generated_Code/AD1.c **** **         device data structure memory, interrupts vectors, etc.
 212:../Generated_Code/AD1.c **** **     Parameters  :
 213:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 214:../Generated_Code/AD1.c **** **       * DeviceDataPtr   - Device data structure
 215:../Generated_Code/AD1.c **** **                           pointer returned by <Init> method.
 216:../Generated_Code/AD1.c **** **     Returns     : Nothing
 217:../Generated_Code/AD1.c **** ** ===================================================================
 218:../Generated_Code/AD1.c **** */
 219:../Generated_Code/AD1.c **** void AD1_Deinit(LDD_TDeviceData *DeviceDataPtr)
 220:../Generated_Code/AD1.c **** {
 203              		.loc 1 220 0
 204              		.cfi_startproc
 205              		@ args = 0, pretend = 0, frame = 8
 206              		@ frame_needed = 1, uses_anonymous_args = 0
 207              		@ link register save eliminated.
 208 0000 80B4     		push	{r7}
 209              	.LCFI3:
 210              		.cfi_def_cfa_offset 4
 211              		.cfi_offset 7, -4
 212 0002 83B0     		sub	sp, sp, #12
 213              	.LCFI4:
 214              		.cfi_def_cfa_offset 16
 215 0004 00AF     		add	r7, sp, #0
 216              	.LCFI5:
 217              		.cfi_def_cfa_register 7
 218 0006 7860     		str	r0, [r7, #4]
 221:../Generated_Code/AD1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 222:../Generated_Code/AD1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 223:../Generated_Code/AD1.c ****   ADC0_SC1A = ADC_SC1_ADCH(0x1F);                                                   
 219              		.loc 1 223 0
 220 0008 4FF43043 		mov	r3, #45056
 221 000c C4F20303 		movt	r3, 16387
 222 0010 4FF01F02 		mov	r2, #31
 223 0014 1A60     		str	r2, [r3, #0]
 224:../Generated_Code/AD1.c ****   /* Interrupt vector(s) deallocation */
 225:../Generated_Code/AD1.c ****   /* {Default RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
 226:../Generated_Code/AD1.c ****   /* Unregistration of the device structure */
 227:../Generated_Code/AD1.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_AD1_ID);
 224              		.loc 1 227 0
 225 0016 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 226 001a C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 227 001e 4FF00002 		mov	r2, #0
 228 0022 DA61     		str	r2, [r3, #28]
 228:../Generated_Code/AD1.c ****   /* Deallocation of the device structure */
 229:../Generated_Code/AD1.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 230:../Generated_Code/AD1.c ****   /* SIM_SCGC6: ADC0=0 */
 231:../Generated_Code/AD1.c ****   SIM_SCGC6 &= (uint32_t)~(uint32_t)(SIM_SCGC6_ADC0_MASK);                                         
 229              		.loc 1 231 0
 230 0024 4FF4E043 		mov	r3, #28672
 231 0028 C4F20403 		movt	r3, 16388
 232 002c 4FF4E042 		mov	r2, #28672
 233 0030 C4F20402 		movt	r2, 16388
 234 0034 02F58052 		add	r2, r2, #4096
 235 0038 02F13C02 		add	r2, r2, #60
 236 003c 1268     		ldr	r2, [r2, #0]
 237 003e 22F00062 		bic	r2, r2, #134217728
 238 0042 03F58053 		add	r3, r3, #4096
 239 0046 03F13C03 		add	r3, r3, #60
 240 004a 1A60     		str	r2, [r3, #0]
 232:../Generated_Code/AD1.c **** }
 241              		.loc 1 232 0
 242 004c 07F10C07 		add	r7, r7, #12
 243 0050 BD46     		mov	sp, r7
 244 0052 80BC     		pop	{r7}
 245 0054 7047     		bx	lr
 246              		.cfi_endproc
 247              	.LFE1:
 249 0056 00BF     		.section	.text.AD1_StartSingleMeasurement,"ax",%progbits
 250              		.align	2
 251              		.global	AD1_StartSingleMeasurement
 252              		.thumb
 253              		.thumb_func
 255              	AD1_StartSingleMeasurement:
 256              	.LFB2:
 233:../Generated_Code/AD1.c **** 
 234:../Generated_Code/AD1.c **** /*
 235:../Generated_Code/AD1.c **** ** ===================================================================
 236:../Generated_Code/AD1.c **** **     Method      :  AD1_StartSingleMeasurement (component ADC_LDD)
 237:../Generated_Code/AD1.c **** **
 238:../Generated_Code/AD1.c **** **     Description :
 239:../Generated_Code/AD1.c **** **         This method starts one measurement of the selected group of
 240:../Generated_Code/AD1.c **** **         samples and exits immediately. The group of samples for
 241:../Generated_Code/AD1.c **** **         measurement is specified by preceding call to
 242:../Generated_Code/AD1.c **** **         <SelectSampleGroup()> or <SelectSampleGroup()> method. The
 243:../Generated_Code/AD1.c **** **         <OnMeasurementComplete() > event is invoked after the
 244:../Generated_Code/AD1.c **** **         measurement is done and the event is enabled. The state of
 245:../Generated_Code/AD1.c **** **         the measurement can be also polled by the
 246:../Generated_Code/AD1.c **** **         <GetMeasurementCompleteStatus()> method. Results of the
 247:../Generated_Code/AD1.c **** **         measurement can be read by the <GetMeasuredValues()> method.
 248:../Generated_Code/AD1.c **** **         The <Discontinuous mode> doesn't support this method.
 249:../Generated_Code/AD1.c **** **     Parameters  :
 250:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 251:../Generated_Code/AD1.c **** **       * DeviceDataPtr   - Device data structure
 252:../Generated_Code/AD1.c **** **                           pointer returned by <Init> method.
 253:../Generated_Code/AD1.c **** **     Returns     :
 254:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 255:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 256:../Generated_Code/AD1.c **** **                           ERR_SPEED - The device doesn't work in the
 257:../Generated_Code/AD1.c **** **                           active clock configuration
 258:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Component is disabled
 259:../Generated_Code/AD1.c **** **                           ERR_BUSY - A measurement is in progress 
 260:../Generated_Code/AD1.c **** ** ===================================================================
 261:../Generated_Code/AD1.c **** */
 262:../Generated_Code/AD1.c **** LDD_TError AD1_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr)
 263:../Generated_Code/AD1.c **** {
 257              		.loc 1 263 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 8
 260              		@ frame_needed = 1, uses_anonymous_args = 0
 261              		@ link register save eliminated.
 262 0000 80B4     		push	{r7}
 263              	.LCFI6:
 264              		.cfi_def_cfa_offset 4
 265              		.cfi_offset 7, -4
 266 0002 83B0     		sub	sp, sp, #12
 267              	.LCFI7:
 268              		.cfi_def_cfa_offset 16
 269 0004 00AF     		add	r7, sp, #0
 270              	.LCFI8:
 271              		.cfi_def_cfa_register 7
 272 0006 7860     		str	r0, [r7, #4]
 264:../Generated_Code/AD1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 265:../Generated_Code/AD1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 273              		.loc 1 265 0
 274 0008 4FF43043 		mov	r3, #45056
 275 000c C4F20303 		movt	r3, 16387
 276 0010 1B6A     		ldr	r3, [r3, #32]
 277 0012 03F08003 		and	r3, r3, #128
 278 0016 002B     		cmp	r3, #0
 279 0018 02D0     		beq	.L4
 266:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 280              		.loc 1 266 0
 281 001a 4FF00803 		mov	r3, #8
 282 001e 20E0     		b	.L5
 283              	.L4:
 267:../Generated_Code/AD1.c ****   }
 268:../Generated_Code/AD1.c ****   ADC_PDD_SetContinuousMode(ADC0_BASE_PTR, ADC_PDD_ONE_CONVERSION); /* Set one conversion mode */
 284              		.loc 1 268 0
 285 0020 4FF43043 		mov	r3, #45056
 286 0024 C4F20303 		movt	r3, 16387
 287 0028 4FF43042 		mov	r2, #45056
 288 002c C4F20302 		movt	r2, 16387
 289 0030 526A     		ldr	r2, [r2, #36]
 290 0032 22F00802 		bic	r2, r2, #8
 291 0036 5A62     		str	r2, [r3, #36]
 269:../Generated_Code/AD1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 292              		.loc 1 269 0
 293 0038 4FF43043 		mov	r3, #45056
 294 003c C4F20303 		movt	r3, 16387
 295 0040 4FF43042 		mov	r2, #45056
 296 0044 C4F20302 		movt	r2, 16387
 297 0048 126A     		ldr	r2, [r2, #32]
 298 004a 22F04002 		bic	r2, r2, #64
 299 004e 1A62     		str	r2, [r3, #32]
 270:../Generated_Code/AD1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ((AD1_TDeviceDataPtr)DeviceDataPtr)->FirstSampl
 300              		.loc 1 270 0
 301 0050 4FF43043 		mov	r3, #45056
 302 0054 C4F20303 		movt	r3, 16387
 303 0058 7A68     		ldr	r2, [r7, #4]
 304 005a 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 305 005c 1A60     		str	r2, [r3, #0]
 271:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 306              		.loc 1 271 0
 307 005e 4FF00003 		mov	r3, #0
 308              	.L5:
 272:../Generated_Code/AD1.c **** }
 309              		.loc 1 272 0
 310 0062 1846     		mov	r0, r3
 311 0064 07F10C07 		add	r7, r7, #12
 312 0068 BD46     		mov	sp, r7
 313 006a 80BC     		pop	{r7}
 314 006c 7047     		bx	lr
 315              		.cfi_endproc
 316              	.LFE2:
 318 006e 00BF     		.section	.text.AD1_StartLoopMeasurement,"ax",%progbits
 319              		.align	2
 320              		.global	AD1_StartLoopMeasurement
 321              		.thumb
 322              		.thumb_func
 324              	AD1_StartLoopMeasurement:
 325              	.LFB3:
 273:../Generated_Code/AD1.c **** 
 274:../Generated_Code/AD1.c **** /*
 275:../Generated_Code/AD1.c **** ** ===================================================================
 276:../Generated_Code/AD1.c **** **     Method      :  AD1_StartLoopMeasurement (component ADC_LDD)
 277:../Generated_Code/AD1.c **** **
 278:../Generated_Code/AD1.c **** **     Description :
 279:../Generated_Code/AD1.c **** **         This method starts periodic measurement of the selected
 280:../Generated_Code/AD1.c **** **         group of and exits immediately. The group of samples for
 281:../Generated_Code/AD1.c **** **         measurement is specified by preceding call to
 282:../Generated_Code/AD1.c **** **         <SelectSampleGroup()> or <SelectSampleGroup()> method. The
 283:../Generated_Code/AD1.c **** **         <OnMeasurementComplete()> event is invoked after the each
 284:../Generated_Code/AD1.c **** **         measurement is done and the event is enabled. The state of
 285:../Generated_Code/AD1.c **** **         the measurement can be also polled by the
 286:../Generated_Code/AD1.c **** **         <GetMeasurementCompleteStatus()> method. Results of the
 287:../Generated_Code/AD1.c **** **         measurement can be read by the <GetMeasuredValues()> method.
 288:../Generated_Code/AD1.c **** **         This method is available only if HW supports loop
 289:../Generated_Code/AD1.c **** **         measurement. The <Discontinuous mode> doesn't support this
 290:../Generated_Code/AD1.c **** **         method.
 291:../Generated_Code/AD1.c **** **     Parameters  :
 292:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 293:../Generated_Code/AD1.c **** **       * DeviceDataPtr   - Device data structure
 294:../Generated_Code/AD1.c **** **                           pointer returned by <Init> method.
 295:../Generated_Code/AD1.c **** **     Returns     :
 296:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 297:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 298:../Generated_Code/AD1.c **** **                           ERR_SPEED - The device doesn't work in the
 299:../Generated_Code/AD1.c **** **                           active clock configuration
 300:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Component is disabled
 301:../Generated_Code/AD1.c **** **                           ERR_BUSY - Measurement is in progress 
 302:../Generated_Code/AD1.c **** ** ===================================================================
 303:../Generated_Code/AD1.c **** */
 304:../Generated_Code/AD1.c **** LDD_TError AD1_StartLoopMeasurement(LDD_TDeviceData *DeviceDataPtr)
 305:../Generated_Code/AD1.c **** {
 326              		.loc 1 305 0
 327              		.cfi_startproc
 328              		@ args = 0, pretend = 0, frame = 8
 329              		@ frame_needed = 1, uses_anonymous_args = 0
 330              		@ link register save eliminated.
 331 0000 80B4     		push	{r7}
 332              	.LCFI9:
 333              		.cfi_def_cfa_offset 4
 334              		.cfi_offset 7, -4
 335 0002 83B0     		sub	sp, sp, #12
 336              	.LCFI10:
 337              		.cfi_def_cfa_offset 16
 338 0004 00AF     		add	r7, sp, #0
 339              	.LCFI11:
 340              		.cfi_def_cfa_register 7
 341 0006 7860     		str	r0, [r7, #4]
 306:../Generated_Code/AD1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 307:../Generated_Code/AD1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 342              		.loc 1 307 0
 343 0008 4FF43043 		mov	r3, #45056
 344 000c C4F20303 		movt	r3, 16387
 345 0010 1B6A     		ldr	r3, [r3, #32]
 346 0012 03F08003 		and	r3, r3, #128
 347 0016 002B     		cmp	r3, #0
 348 0018 02D0     		beq	.L7
 308:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 349              		.loc 1 308 0
 350 001a 4FF00803 		mov	r3, #8
 351 001e 20E0     		b	.L8
 352              	.L7:
 309:../Generated_Code/AD1.c ****   }
 310:../Generated_Code/AD1.c ****   ADC_PDD_SetContinuousMode(ADC0_BASE_PTR, ADC_PDD_CONTINUOUS_CONVERSIONS); /* Set continuous conve
 353              		.loc 1 310 0
 354 0020 4FF43043 		mov	r3, #45056
 355 0024 C4F20303 		movt	r3, 16387
 356 0028 4FF43042 		mov	r2, #45056
 357 002c C4F20302 		movt	r2, 16387
 358 0030 526A     		ldr	r2, [r2, #36]
 359 0032 42F00802 		orr	r2, r2, #8
 360 0036 5A62     		str	r2, [r3, #36]
 311:../Generated_Code/AD1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 361              		.loc 1 311 0
 362 0038 4FF43043 		mov	r3, #45056
 363 003c C4F20303 		movt	r3, 16387
 364 0040 4FF43042 		mov	r2, #45056
 365 0044 C4F20302 		movt	r2, 16387
 366 0048 126A     		ldr	r2, [r2, #32]
 367 004a 22F04002 		bic	r2, r2, #64
 368 004e 1A62     		str	r2, [r3, #32]
 312:../Generated_Code/AD1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ((AD1_TDeviceDataPtr)DeviceDataPtr)->FirstSampl
 369              		.loc 1 312 0
 370 0050 4FF43043 		mov	r3, #45056
 371 0054 C4F20303 		movt	r3, 16387
 372 0058 7A68     		ldr	r2, [r7, #4]
 373 005a 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 374 005c 1A60     		str	r2, [r3, #0]
 313:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 375              		.loc 1 313 0
 376 005e 4FF00003 		mov	r3, #0
 377              	.L8:
 314:../Generated_Code/AD1.c **** }
 378              		.loc 1 314 0
 379 0062 1846     		mov	r0, r3
 380 0064 07F10C07 		add	r7, r7, #12
 381 0068 BD46     		mov	sp, r7
 382 006a 80BC     		pop	{r7}
 383 006c 7047     		bx	lr
 384              		.cfi_endproc
 385              	.LFE3:
 387 006e 00BF     		.section	.text.AD1_StartLoopTriggeredMeasurement,"ax",%progbits
 388              		.align	2
 389              		.global	AD1_StartLoopTriggeredMeasurement
 390              		.thumb
 391              		.thumb_func
 393              	AD1_StartLoopTriggeredMeasurement:
 394              	.LFB4:
 315:../Generated_Code/AD1.c **** 
 316:../Generated_Code/AD1.c **** /*
 317:../Generated_Code/AD1.c **** ** ===================================================================
 318:../Generated_Code/AD1.c **** **     Method      :  AD1_StartLoopTriggeredMeasurement (component ADC_LDD)
 319:../Generated_Code/AD1.c **** **
 320:../Generated_Code/AD1.c **** **     Description :
 321:../Generated_Code/AD1.c **** **         This method prepares periodic measurement of the selected
 322:../Generated_Code/AD1.c **** **         group of samples and exits immediately. The measurement is
 323:../Generated_Code/AD1.c **** **         started each time the trigger is activated. The group of
 324:../Generated_Code/AD1.c **** **         samples for measurement is specified by preceding call to
 325:../Generated_Code/AD1.c **** **         <SelectSampleGroup()> or <SelectSampleGroup()> method. The
 326:../Generated_Code/AD1.c **** **         <OnMeasurementComplete()> event is invoked after the each
 327:../Generated_Code/AD1.c **** **         measurement is done and the event is enabled. The state of
 328:../Generated_Code/AD1.c **** **         the measurement can be also polled by the
 329:../Generated_Code/AD1.c **** **         <GetMeasurementCompleteStatus()> method. Results of the
 330:../Generated_Code/AD1.c **** **         measurement can be read by the <GetMeasuredValues()> method.
 331:../Generated_Code/AD1.c **** **         This method is available only if HW supports triggered
 332:../Generated_Code/AD1.c **** **         measurement and <Trigger> is enabled.
 333:../Generated_Code/AD1.c **** **     Parameters  :
 334:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 335:../Generated_Code/AD1.c **** **       * DeviceDataPtr   - Device data structure
 336:../Generated_Code/AD1.c **** **                           pointer returned by <Init> method.
 337:../Generated_Code/AD1.c **** **     Returns     :
 338:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 339:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 340:../Generated_Code/AD1.c **** **                           ERR_SPEED - The device doesn't work in the
 341:../Generated_Code/AD1.c **** **                           active clock configuration
 342:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Component is disabled
 343:../Generated_Code/AD1.c **** **                           ERR_BUSY - Measurement is in progress 
 344:../Generated_Code/AD1.c **** ** ===================================================================
 345:../Generated_Code/AD1.c **** */
 346:../Generated_Code/AD1.c **** LDD_TError AD1_StartLoopTriggeredMeasurement(LDD_TDeviceData *DeviceDataPtr)
 347:../Generated_Code/AD1.c **** {
 395              		.loc 1 347 0
 396              		.cfi_startproc
 397              		@ args = 0, pretend = 0, frame = 8
 398              		@ frame_needed = 1, uses_anonymous_args = 0
 399              		@ link register save eliminated.
 400 0000 80B4     		push	{r7}
 401              	.LCFI12:
 402              		.cfi_def_cfa_offset 4
 403              		.cfi_offset 7, -4
 404 0002 83B0     		sub	sp, sp, #12
 405              	.LCFI13:
 406              		.cfi_def_cfa_offset 16
 407 0004 00AF     		add	r7, sp, #0
 408              	.LCFI14:
 409              		.cfi_def_cfa_register 7
 410 0006 7860     		str	r0, [r7, #4]
 348:../Generated_Code/AD1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 349:../Generated_Code/AD1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 411              		.loc 1 349 0
 412 0008 4FF43043 		mov	r3, #45056
 413 000c C4F20303 		movt	r3, 16387
 414 0010 1B6A     		ldr	r3, [r3, #32]
 415 0012 03F08003 		and	r3, r3, #128
 416 0016 002B     		cmp	r3, #0
 417 0018 02D0     		beq	.L10
 350:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 418              		.loc 1 350 0
 419 001a 4FF00803 		mov	r3, #8
 420 001e 20E0     		b	.L11
 421              	.L10:
 351:../Generated_Code/AD1.c ****   }
 352:../Generated_Code/AD1.c ****   ADC_PDD_SetContinuousMode(ADC0_BASE_PTR, ADC_PDD_ONE_CONVERSION); /* Set one conversion mode */
 422              		.loc 1 352 0
 423 0020 4FF43043 		mov	r3, #45056
 424 0024 C4F20303 		movt	r3, 16387
 425 0028 4FF43042 		mov	r2, #45056
 426 002c C4F20302 		movt	r2, 16387
 427 0030 526A     		ldr	r2, [r2, #36]
 428 0032 22F00802 		bic	r2, r2, #8
 429 0036 5A62     		str	r2, [r3, #36]
 353:../Generated_Code/AD1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_HW_TRIGGER); /* Select HW triggering */
 430              		.loc 1 353 0
 431 0038 4FF43043 		mov	r3, #45056
 432 003c C4F20303 		movt	r3, 16387
 433 0040 4FF43042 		mov	r2, #45056
 434 0044 C4F20302 		movt	r2, 16387
 435 0048 126A     		ldr	r2, [r2, #32]
 436 004a 42F04002 		orr	r2, r2, #64
 437 004e 1A62     		str	r2, [r3, #32]
 354:../Generated_Code/AD1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ((AD1_TDeviceDataPtr)DeviceDataPtr)->FirstSampl
 438              		.loc 1 354 0
 439 0050 4FF43043 		mov	r3, #45056
 440 0054 C4F20303 		movt	r3, 16387
 441 0058 7A68     		ldr	r2, [r7, #4]
 442 005a 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 443 005c 1A60     		str	r2, [r3, #0]
 355:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 444              		.loc 1 355 0
 445 005e 4FF00003 		mov	r3, #0
 446              	.L11:
 356:../Generated_Code/AD1.c **** }
 447              		.loc 1 356 0
 448 0062 1846     		mov	r0, r3
 449 0064 07F10C07 		add	r7, r7, #12
 450 0068 BD46     		mov	sp, r7
 451 006a 80BC     		pop	{r7}
 452 006c 7047     		bx	lr
 453              		.cfi_endproc
 454              	.LFE4:
 456 006e 00BF     		.section	.text.AD1_SelectSampleGroup,"ax",%progbits
 457              		.align	2
 458              		.global	AD1_SelectSampleGroup
 459              		.thumb
 460              		.thumb_func
 462              	AD1_SelectSampleGroup:
 463              	.LFB5:
 357:../Generated_Code/AD1.c **** 
 358:../Generated_Code/AD1.c **** /*
 359:../Generated_Code/AD1.c **** ** ===================================================================
 360:../Generated_Code/AD1.c **** **     Method      :  AD1_SelectSampleGroup (component ADC_LDD)
 361:../Generated_Code/AD1.c **** **
 362:../Generated_Code/AD1.c **** **     Description :
 363:../Generated_Code/AD1.c **** **         This method selects one of the (design-time) predefined
 364:../Generated_Code/AD1.c **** **         <Static sample groups> for the next measurement. Each call
 365:../Generated_Code/AD1.c **** **         rewrites the preceding setting. Once any group is selected,
 366:../Generated_Code/AD1.c **** **         the measurement can be started multiple times. Note: This
 367:../Generated_Code/AD1.c **** **         method works only with the sample groups defined at design
 368:../Generated_Code/AD1.c **** **         time. For run-time defined groups use <CreateSampleGroup()>
 369:../Generated_Code/AD1.c **** **         method.
 370:../Generated_Code/AD1.c **** **     Parameters  :
 371:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 372:../Generated_Code/AD1.c **** **       * DeviceDataPtr   - Device data structure
 373:../Generated_Code/AD1.c **** **                           pointer returned by <Init> method.
 374:../Generated_Code/AD1.c **** **         GroupIndex      - Group index.
 375:../Generated_Code/AD1.c **** **     Returns     :
 376:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 377:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 378:../Generated_Code/AD1.c **** **                           ERR_SPEED - The device doesn't work in the
 379:../Generated_Code/AD1.c **** **                           active clock configuration
 380:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Component is disabled
 381:../Generated_Code/AD1.c **** **                           ERR_PARAM_GROUP - SampleGroup parameter
 382:../Generated_Code/AD1.c **** **                           value is out of range
 383:../Generated_Code/AD1.c **** **                           ERR_BUSY - Measurement is in progress 
 384:../Generated_Code/AD1.c **** ** ===================================================================
 385:../Generated_Code/AD1.c **** */
 386:../Generated_Code/AD1.c **** LDD_TError AD1_SelectSampleGroup(LDD_TDeviceData *DeviceDataPtr, uint8_t GroupIndex)
 387:../Generated_Code/AD1.c **** {
 464              		.loc 1 387 0
 465              		.cfi_startproc
 466              		@ args = 0, pretend = 0, frame = 16
 467              		@ frame_needed = 1, uses_anonymous_args = 0
 468              		@ link register save eliminated.
 469 0000 80B4     		push	{r7}
 470              	.LCFI15:
 471              		.cfi_def_cfa_offset 4
 472              		.cfi_offset 7, -4
 473 0002 85B0     		sub	sp, sp, #20
 474              	.LCFI16:
 475              		.cfi_def_cfa_offset 24
 476 0004 00AF     		add	r7, sp, #0
 477              	.LCFI17:
 478              		.cfi_def_cfa_register 7
 479 0006 7860     		str	r0, [r7, #4]
 480 0008 0B46     		mov	r3, r1
 481 000a FB70     		strb	r3, [r7, #3]
 388:../Generated_Code/AD1.c ****   AD1_TDeviceDataPtr DeviceDataPrv = (AD1_TDeviceDataPtr)DeviceDataPtr;
 482              		.loc 1 388 0
 483 000c 7B68     		ldr	r3, [r7, #4]
 484 000e FB60     		str	r3, [r7, #12]
 389:../Generated_Code/AD1.c ****   const TStaticSampleGroup * GroupPtr;
 390:../Generated_Code/AD1.c **** 
 391:../Generated_Code/AD1.c ****   /* Group index test - this test can be disabled by setting the "Ignore range checking"
 392:../Generated_Code/AD1.c ****      property to the "yes" value in the "Configuration inspector" */
 393:../Generated_Code/AD1.c ****   if (GroupIndex >= AD1_STATIC_GROUP_COUNT) { /* Is GroupIndex out of range? */
 485              		.loc 1 393 0
 486 0010 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 487 0012 002B     		cmp	r3, #0
 488 0014 02D0     		beq	.L13
 394:../Generated_Code/AD1.c ****     return ERR_PARAM_GROUP;            /* Yes, return ERR_PARAM_GROUP */
 489              		.loc 1 394 0
 490 0016 4FF09303 		mov	r3, #147
 491 001a 1EE0     		b	.L14
 492              	.L13:
 395:../Generated_Code/AD1.c ****   }
 396:../Generated_Code/AD1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 493              		.loc 1 396 0
 494 001c 4FF43043 		mov	r3, #45056
 495 0020 C4F20303 		movt	r3, 16387
 496 0024 1B6A     		ldr	r3, [r3, #32]
 497 0026 03F08003 		and	r3, r3, #128
 498 002a 002B     		cmp	r3, #0
 499 002c 02D0     		beq	.L15
 397:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 500              		.loc 1 397 0
 501 002e 4FF00803 		mov	r3, #8
 502 0032 12E0     		b	.L14
 503              	.L15:
 398:../Generated_Code/AD1.c ****   }
 399:../Generated_Code/AD1.c ****   GroupPtr = &StaticSampleGroups[GroupIndex]; /* Remember static sample group address */
 504              		.loc 1 399 0
 505 0034 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 506 0036 4FEA4302 		lsl	r2, r3, #1
 507 003a 40F20003 		movw	r3, #:lower16:StaticSampleGroups
 508 003e C0F20003 		movt	r3, #:upper16:StaticSampleGroups
 509 0042 D318     		adds	r3, r2, r3
 510 0044 BB60     		str	r3, [r7, #8]
 400:../Generated_Code/AD1.c ****   DeviceDataPrv->FirstSample = GroupPtr->StatusControlRegVal[0]; /* Remember first sample */
 511              		.loc 1 400 0
 512 0046 BB68     		ldr	r3, [r7, #8]
 513 0048 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 514 004a FB68     		ldr	r3, [r7, #12]
 515 004c 5A70     		strb	r2, [r3, #1]
 401:../Generated_Code/AD1.c ****   DeviceDataPrv->SampleCount = GroupPtr->SampleCount; /* Remember sample count */
 516              		.loc 1 401 0
 517 004e BB68     		ldr	r3, [r7, #8]
 518 0050 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 519 0052 FB68     		ldr	r3, [r7, #12]
 520 0054 1A70     		strb	r2, [r3, #0]
 402:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 521              		.loc 1 402 0
 522 0056 4FF00003 		mov	r3, #0
 523              	.L14:
 403:../Generated_Code/AD1.c **** }
 524              		.loc 1 403 0
 525 005a 1846     		mov	r0, r3
 526 005c 07F11407 		add	r7, r7, #20
 527 0060 BD46     		mov	sp, r7
 528 0062 80BC     		pop	{r7}
 529 0064 7047     		bx	lr
 530              		.cfi_endproc
 531              	.LFE5:
 533 0066 00BF     		.section	.text.AD1_CreateSampleGroup,"ax",%progbits
 534              		.align	2
 535              		.global	AD1_CreateSampleGroup
 536              		.thumb
 537              		.thumb_func
 539              	AD1_CreateSampleGroup:
 540              	.LFB6:
 404:../Generated_Code/AD1.c **** 
 405:../Generated_Code/AD1.c **** /*
 406:../Generated_Code/AD1.c **** ** ===================================================================
 407:../Generated_Code/AD1.c **** **     Method      :  AD1_CreateSampleGroup (component ADC_LDD)
 408:../Generated_Code/AD1.c **** **
 409:../Generated_Code/AD1.c **** **     Description :
 410:../Generated_Code/AD1.c **** **         This method prepares HW for next measurement according to
 411:../Generated_Code/AD1.c **** **         array of samples defined during run-time. The array of
 412:../Generated_Code/AD1.c **** **         samples should be prepared prior to calling this method.
 413:../Generated_Code/AD1.c **** **         Pointer to the array is passed into this method in parameter
 414:../Generated_Code/AD1.c **** **         SampleGroupPtr. The number of samples is defined by
 415:../Generated_Code/AD1.c **** **         parameter SampleCount. Once any group is prepared, the
 416:../Generated_Code/AD1.c **** **         measurement can be started multiple times. Note: This method
 417:../Generated_Code/AD1.c **** **         works only with the sample groups defined during run-time.
 418:../Generated_Code/AD1.c **** **         For design-time defined groups use <SelectSampleGroup()>
 419:../Generated_Code/AD1.c **** **         method.
 420:../Generated_Code/AD1.c **** **     Parameters  :
 421:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 422:../Generated_Code/AD1.c **** **       * DeviceDataPtr   - Device data structure
 423:../Generated_Code/AD1.c **** **                           pointer returned by <Init> method.
 424:../Generated_Code/AD1.c **** **       * SampleGroupPtr  - Pointer to the
 425:../Generated_Code/AD1.c **** **                           sample definition array. This array can be
 426:../Generated_Code/AD1.c **** **                           released as soon as the method ends.
 427:../Generated_Code/AD1.c **** **         SampleCount     - Number of items in the
 428:../Generated_Code/AD1.c **** **                           sample definition array. Must be less than
 429:../Generated_Code/AD1.c **** **                           or equal to
 430:../Generated_Code/AD1.c **** **                           ComponentName_MAX_HW_SAMPLE_COUNT.
 431:../Generated_Code/AD1.c **** **     Returns     :
 432:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 433:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 434:../Generated_Code/AD1.c **** **                           ERR_SPEED - The device doesn't work in the
 435:../Generated_Code/AD1.c **** **                           active clock configuration
 436:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Component is disabled
 437:../Generated_Code/AD1.c **** **                           ERR_PARAM_INDEX - Channel index in
 438:../Generated_Code/AD1.c **** **                           SampleGroup structure is out of range
 439:../Generated_Code/AD1.c **** **                           ERR_PARAM_SAMPLE_COUNT - SampleCount
 440:../Generated_Code/AD1.c **** **                           variable value is out of range
 441:../Generated_Code/AD1.c **** **                           ERR_BUSY - Measurement is in progress 
 442:../Generated_Code/AD1.c **** ** ===================================================================
 443:../Generated_Code/AD1.c **** */
 444:../Generated_Code/AD1.c **** LDD_TError AD1_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr, LDD_ADC_TSample *SampleGroupPtr, u
 445:../Generated_Code/AD1.c **** {
 541              		.loc 1 445 0
 542              		.cfi_startproc
 543              		@ args = 0, pretend = 0, frame = 24
 544              		@ frame_needed = 1, uses_anonymous_args = 0
 545              		@ link register save eliminated.
 546 0000 80B4     		push	{r7}
 547              	.LCFI18:
 548              		.cfi_def_cfa_offset 4
 549              		.cfi_offset 7, -4
 550 0002 87B0     		sub	sp, sp, #28
 551              	.LCFI19:
 552              		.cfi_def_cfa_offset 32
 553 0004 00AF     		add	r7, sp, #0
 554              	.LCFI20:
 555              		.cfi_def_cfa_register 7
 556 0006 F860     		str	r0, [r7, #12]
 557 0008 B960     		str	r1, [r7, #8]
 558 000a 1346     		mov	r3, r2
 559 000c FB71     		strb	r3, [r7, #7]
 446:../Generated_Code/AD1.c ****   AD1_TDeviceDataPtr DeviceDataPrv = (AD1_TDeviceDataPtr)DeviceDataPtr;
 560              		.loc 1 446 0
 561 000e FB68     		ldr	r3, [r7, #12]
 562 0010 7B61     		str	r3, [r7, #20]
 447:../Generated_Code/AD1.c **** 
 448:../Generated_Code/AD1.c ****   /* Sample count test - this test can be disabled by setting the "Ignore range checking"
 449:../Generated_Code/AD1.c ****      property to the "yes" value in the "Configuration inspector" */
 450:../Generated_Code/AD1.c ****   if ((SampleCount > AD1_MAX_HW_SAMPLE_COUNT) || (SampleCount == 0U)) { /* Is number of sample grea
 563              		.loc 1 450 0
 564 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 565 0014 012B     		cmp	r3, #1
 566 0016 02D8     		bhi	.L17
 567              		.loc 1 450 0 is_stmt 0 discriminator 1
 568 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 569 001a 002B     		cmp	r3, #0
 570 001c 02D1     		bne	.L18
 571              	.L17:
 451:../Generated_Code/AD1.c ****     return ERR_PARAM_SAMPLE_COUNT;     /* Yes, return ERR_PARAM_SAMPLE_COUNT */
 572              		.loc 1 451 0 is_stmt 1
 573 001e 4FF09603 		mov	r3, #150
 574 0022 21E0     		b	.L19
 575              	.L18:
 452:../Generated_Code/AD1.c ****   }
 453:../Generated_Code/AD1.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 576              		.loc 1 453 0
 577 0024 4FF43043 		mov	r3, #45056
 578 0028 C4F20303 		movt	r3, 16387
 579 002c 1B6A     		ldr	r3, [r3, #32]
 580 002e 03F08003 		and	r3, r3, #128
 581 0032 002B     		cmp	r3, #0
 582 0034 02D0     		beq	.L20
 454:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 583              		.loc 1 454 0
 584 0036 4FF00803 		mov	r3, #8
 585 003a 15E0     		b	.L19
 586              	.L20:
 455:../Generated_Code/AD1.c ****   }
 456:../Generated_Code/AD1.c ****   DeviceDataPrv->SampleCount = SampleCount; /* Remember sample count */
 587              		.loc 1 456 0
 588 003c 7B69     		ldr	r3, [r7, #20]
 589 003e FA79     		ldrb	r2, [r7, #7]
 590 0040 1A70     		strb	r2, [r3, #0]
 457:../Generated_Code/AD1.c ****   /* Channel index test - this test can be disabled by setting the "Ignore range checking"
 458:../Generated_Code/AD1.c ****      property to the "yes" value in the "Configuration inspector" */
 459:../Generated_Code/AD1.c ****   if (SampleGroupPtr[0].ChannelIdx >= AD1_CHANNEL_COUNT) { /* Is channel index out of range? */
 591              		.loc 1 459 0
 592 0042 BB68     		ldr	r3, [r7, #8]
 593 0044 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 594 0046 002B     		cmp	r3, #0
 595 0048 02D0     		beq	.L21
 460:../Generated_Code/AD1.c ****     return ERR_PARAM_INDEX;            /* Yes, return ERR_PARAM_INDEX */
 596              		.loc 1 460 0
 597 004a 4FF08203 		mov	r3, #130
 598 004e 0BE0     		b	.L19
 599              	.L21:
 461:../Generated_Code/AD1.c ****   }
 462:../Generated_Code/AD1.c ****   DeviceDataPrv->FirstSample = ChannelToPin[SampleGroupPtr[0].ChannelIdx]; /* Remember first sample
 600              		.loc 1 462 0
 601 0050 BB68     		ldr	r3, [r7, #8]
 602 0052 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 603 0054 1A46     		mov	r2, r3
 604 0056 40F20003 		movw	r3, #:lower16:ChannelToPin
 605 005a C0F20003 		movt	r3, #:upper16:ChannelToPin
 606 005e 9A5C     		ldrb	r2, [r3, r2]	@ zero_extendqisi2
 607 0060 7B69     		ldr	r3, [r7, #20]
 608 0062 5A70     		strb	r2, [r3, #1]
 463:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 609              		.loc 1 463 0
 610 0064 4FF00003 		mov	r3, #0
 611              	.L19:
 464:../Generated_Code/AD1.c **** }
 612              		.loc 1 464 0
 613 0068 1846     		mov	r0, r3
 614 006a 07F11C07 		add	r7, r7, #28
 615 006e BD46     		mov	sp, r7
 616 0070 80BC     		pop	{r7}
 617 0072 7047     		bx	lr
 618              		.cfi_endproc
 619              	.LFE6:
 621              		.section	.text.AD1_GetMeasuredValues,"ax",%progbits
 622              		.align	2
 623              		.global	AD1_GetMeasuredValues
 624              		.thumb
 625              		.thumb_func
 627              	AD1_GetMeasuredValues:
 628              	.LFB7:
 465:../Generated_Code/AD1.c **** 
 466:../Generated_Code/AD1.c **** /*
 467:../Generated_Code/AD1.c **** ** ===================================================================
 468:../Generated_Code/AD1.c **** **     Method      :  AD1_GetMeasuredValues (component ADC_LDD)
 469:../Generated_Code/AD1.c **** **
 470:../Generated_Code/AD1.c **** **     Description :
 471:../Generated_Code/AD1.c **** **         This method copies results of the last measurement to the
 472:../Generated_Code/AD1.c **** **         user supplied buffer. Data size depends on the size of
 473:../Generated_Code/AD1.c **** **         measured sample group (see <SelectSampleGroup()> or
 474:../Generated_Code/AD1.c **** **         <CreateSampleGroup()> method). Data representation is
 475:../Generated_Code/AD1.c **** **         defined by the <Result type> property. Typically this method
 476:../Generated_Code/AD1.c **** **         is called from <OnMeasurementComplete> event to get results
 477:../Generated_Code/AD1.c **** **         of the last measurement.
 478:../Generated_Code/AD1.c **** **     Parameters  :
 479:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 480:../Generated_Code/AD1.c **** **       * DeviceDataPtr   - Device data structure
 481:../Generated_Code/AD1.c **** **                           pointer returned by <Init> method.
 482:../Generated_Code/AD1.c **** **       * BufferPtr       - Pointer to the start of the
 483:../Generated_Code/AD1.c **** **                           buffer for new results. Count of stored
 484:../Generated_Code/AD1.c **** **                           measured values equals to the count of the
 485:../Generated_Code/AD1.c **** **                           samples in the active sample group. It is
 486:../Generated_Code/AD1.c **** **                           in the user responsibility to provide
 487:../Generated_Code/AD1.c **** **                           buffer with appropriate size.
 488:../Generated_Code/AD1.c **** **     Returns     :
 489:../Generated_Code/AD1.c **** **         ---             - Error code, possible codes:
 490:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 491:../Generated_Code/AD1.c **** **                           ERR_SPEED - The device doesn't work in the
 492:../Generated_Code/AD1.c **** **                           active clock configuration
 493:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Component is disabled
 494:../Generated_Code/AD1.c **** ** ===================================================================
 495:../Generated_Code/AD1.c **** */
 496:../Generated_Code/AD1.c **** LDD_TError AD1_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr)
 497:../Generated_Code/AD1.c **** {
 629              		.loc 1 497 0
 630              		.cfi_startproc
 631              		@ args = 0, pretend = 0, frame = 16
 632              		@ frame_needed = 1, uses_anonymous_args = 0
 633              		@ link register save eliminated.
 634 0000 80B4     		push	{r7}
 635              	.LCFI21:
 636              		.cfi_def_cfa_offset 4
 637              		.cfi_offset 7, -4
 638 0002 85B0     		sub	sp, sp, #20
 639              	.LCFI22:
 640              		.cfi_def_cfa_offset 24
 641 0004 00AF     		add	r7, sp, #0
 642              	.LCFI23:
 643              		.cfi_def_cfa_register 7
 644 0006 7860     		str	r0, [r7, #4]
 645 0008 3960     		str	r1, [r7, #0]
 498:../Generated_Code/AD1.c ****   uint8_t Sample;
 499:../Generated_Code/AD1.c ****   AD1_TResultData *pBuffer = (AD1_TResultData *)BufferPtr;
 646              		.loc 1 499 0
 647 000a 3B68     		ldr	r3, [r7, #0]
 648 000c BB60     		str	r3, [r7, #8]
 500:../Generated_Code/AD1.c **** 
 501:../Generated_Code/AD1.c ****   /* Copy values from result registers defined in the active sample
 502:../Generated_Code/AD1.c ****      group to the user supplied buffer */
 503:../Generated_Code/AD1.c ****   for (Sample = 0U; Sample < ((AD1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 649              		.loc 1 503 0
 650 000e 4FF00003 		mov	r3, #0
 651 0012 FB73     		strb	r3, [r7, #15]
 652 0014 11E0     		b	.L23
 653              	.L24:
 504:../Generated_Code/AD1.c ****     pBuffer[Sample] = (uint8_t)(ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, Sample));
 654              		.loc 1 504 0 discriminator 2
 655 0016 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 656 0018 BA68     		ldr	r2, [r7, #8]
 657 001a D218     		adds	r2, r2, r3
 658 001c 4FF43043 		mov	r3, #45056
 659 0020 C4F20303 		movt	r3, 16387
 660 0024 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 661 0026 01F10401 		add	r1, r1, #4
 662 002a 53F82130 		ldr	r3, [r3, r1, lsl #2]
 663 002e DBB2     		uxtb	r3, r3
 664 0030 1370     		strb	r3, [r2, #0]
 503:../Generated_Code/AD1.c ****   for (Sample = 0U; Sample < ((AD1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 665              		.loc 1 503 0 discriminator 2
 666 0032 FB7B     		ldrb	r3, [r7, #15]
 667 0034 03F10103 		add	r3, r3, #1
 668 0038 FB73     		strb	r3, [r7, #15]
 669              	.L23:
 503:../Generated_Code/AD1.c ****   for (Sample = 0U; Sample < ((AD1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 670              		.loc 1 503 0 is_stmt 0 discriminator 1
 671 003a 7B68     		ldr	r3, [r7, #4]
 672 003c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 673 003e FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 674 0040 9A42     		cmp	r2, r3
 675 0042 E8D3     		bcc	.L24
 505:../Generated_Code/AD1.c ****   }
 506:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 676              		.loc 1 506 0 is_stmt 1
 677 0044 4FF00003 		mov	r3, #0
 507:../Generated_Code/AD1.c **** }
 678              		.loc 1 507 0
 679 0048 1846     		mov	r0, r3
 680 004a 07F11407 		add	r7, r7, #20
 681 004e BD46     		mov	sp, r7
 682 0050 80BC     		pop	{r7}
 683 0052 7047     		bx	lr
 684              		.cfi_endproc
 685              	.LFE7:
 687              		.section	.text.AD1_MeasurementCompleteInterrupt,"ax",%progbits
 688              		.align	2
 689              		.global	AD1_MeasurementCompleteInterrupt
 690              		.thumb
 691              		.thumb_func
 693              	AD1_MeasurementCompleteInterrupt:
 694              	.LFB8:
 508:../Generated_Code/AD1.c **** 
 509:../Generated_Code/AD1.c **** /*
 510:../Generated_Code/AD1.c **** ** ===================================================================
 511:../Generated_Code/AD1.c **** **     Method      :  AD1_MeasurementCompleteInterrupt (component ADC_LDD)
 512:../Generated_Code/AD1.c **** **
 513:../Generated_Code/AD1.c **** **     Description :
 514:../Generated_Code/AD1.c **** **         Measurement complete interrupt handler
 515:../Generated_Code/AD1.c **** **         This method is internal. It is used by Processor Expert only.
 516:../Generated_Code/AD1.c **** ** ===================================================================
 517:../Generated_Code/AD1.c **** */
 518:../Generated_Code/AD1.c **** PE_ISR(AD1_MeasurementCompleteInterrupt)
 519:../Generated_Code/AD1.c **** {
 695              		.loc 1 519 0
 696              		.cfi_startproc
 697              		@ Stack Align: May be called with mis-aligned SP.
 698              		@ args = 0, pretend = 0, frame = 8
 699              		@ frame_needed = 1, uses_anonymous_args = 0
 700 0000 6846     		mov	r0, sp
 701              		.cfi_register 13, 0
 702 0002 20F00701 		bic	r1, r0, #7
 703 0006 8D46     		mov	sp, r1
 704 0008 81B5     		push	{r0, r7, lr}
 705              	.LCFI24:
 706              		.cfi_def_cfa_offset 12
 707              		.cfi_offset 14, -4
 708              		.cfi_offset 7, -8
 709              		.cfi_offset 13, -12
 710 000a 83B0     		sub	sp, sp, #12
 711              	.LCFI25:
 712              		.cfi_def_cfa_offset 24
 713 000c 00AF     		add	r7, sp, #0
 714              	.LCFI26:
 715              		.cfi_def_cfa_register 7
 520:../Generated_Code/AD1.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 521:../Generated_Code/AD1.c ****   AD1_TDeviceDataPtr DeviceDataPrv = INT_ADC0__DEFAULT_RTOS_ISRPARAM;
 716              		.loc 1 521 0
 717 000e 40F20003 		movw	r3, #:lower16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
 718 0012 C0F20003 		movt	r3, #:upper16:INT_ADC0__DEFAULT_RTOS_ISRPARAM
 719 0016 1B68     		ldr	r3, [r3, #0]
 720 0018 7B60     		str	r3, [r7, #4]
 522:../Generated_Code/AD1.c ****   AD1_OnMeasurementComplete(DeviceDataPrv->UserData);
 721              		.loc 1 522 0
 722 001a 7B68     		ldr	r3, [r7, #4]
 723 001c 5B68     		ldr	r3, [r3, #4]
 724 001e 1846     		mov	r0, r3
 725 0020 FFF7FEFF 		bl	AD1_OnMeasurementComplete
 523:../Generated_Code/AD1.c ****   (void)ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, 0U); /* Clear conversion complete flag */
 726              		.loc 1 523 0
 727 0024 4FF43043 		mov	r3, #45056
 728 0028 C4F20303 		movt	r3, 16387
 729 002c 1B69     		ldr	r3, [r3, #16]
 524:../Generated_Code/AD1.c **** }
 730              		.loc 1 524 0
 731 002e 07F10C07 		add	r7, r7, #12
 732 0032 BD46     		mov	sp, r7
 733 0034 BDE88140 		pop	{r0, r7, lr}
 734 0038 8546     		mov	sp, r0
 735 003a 7047     		bx	lr
 736              		.cfi_endproc
 737              	.LFE8:
 739              		.text
 740              	.Letext0:
 741              		.file 2 "C:/Freescale/CW MCU v10.3_121211/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 742              		.file 3 "C:/temp2/Pex/Generated_Code/IO_Map.h"
 743              		.file 4 "C:/temp2/Pex/Generated_Code/PE_LDD.h"
 744              		.file 5 "C:/temp2/Pex/Generated_Code/AD1.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AD1.c
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:19     .rodata.ChannelToPin:00000000 $d
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:22     .rodata.ChannelToPin:00000000 ChannelToPin
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:25     .rodata.StaticSampleGroups:00000000 $d
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:28     .rodata.StaticSampleGroups:00000000 StaticSampleGroups
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:32     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:35     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:38     .bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:41     .bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM:00000000 INT_ADC0__DEFAULT_RTOS_ISRPARAM
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:44     .text.AD1_Init:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:49     .text.AD1_Init:00000000 AD1_Init
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:196    .text.AD1_Deinit:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:201    .text.AD1_Deinit:00000000 AD1_Deinit
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:250    .text.AD1_StartSingleMeasurement:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:255    .text.AD1_StartSingleMeasurement:00000000 AD1_StartSingleMeasurement
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:319    .text.AD1_StartLoopMeasurement:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:324    .text.AD1_StartLoopMeasurement:00000000 AD1_StartLoopMeasurement
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:388    .text.AD1_StartLoopTriggeredMeasurement:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:393    .text.AD1_StartLoopTriggeredMeasurement:00000000 AD1_StartLoopTriggeredMeasurement
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:457    .text.AD1_SelectSampleGroup:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:462    .text.AD1_SelectSampleGroup:00000000 AD1_SelectSampleGroup
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:534    .text.AD1_CreateSampleGroup:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:539    .text.AD1_CreateSampleGroup:00000000 AD1_CreateSampleGroup
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:622    .text.AD1_GetMeasuredValues:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:627    .text.AD1_GetMeasuredValues:00000000 AD1_GetMeasuredValues
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:688    .text.AD1_MeasurementCompleteInterrupt:00000000 $t
C:\Users\z\AppData\Local\Temp\ccKwTkVn.s:693    .text.AD1_MeasurementCompleteInterrupt:00000000 AD1_MeasurementCompleteInterrupt
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
AD1_OnMeasurementComplete
