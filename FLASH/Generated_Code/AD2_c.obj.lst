   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"AD2.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata.ChannelToPin,"a",%progbits
  19              		.align	2
  22              	ChannelToPin:
  23 0000 0A       		.byte	10
  24 0001 000000   		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  25              		.align	2
  28              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  29 0000 00000000 		.space	8
  29      00000000 
  30              		.section	.text.AD2_Init,"ax",%progbits
  31              		.align	2
  32              		.global	AD2_Init
  33              		.thumb
  34              		.thumb_func
  36              	AD2_Init:
  37              	.LFB0:
  38              		.file 1 "../Generated_Code/AD2.c"
   1:../Generated_Code/AD2.c **** /** ###################################################################
   2:../Generated_Code/AD2.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AD2.c **** **     Filename    : AD2.c
   4:../Generated_Code/AD2.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AD2.c **** **     Processor   : MK40DX256ZVLQ10
   6:../Generated_Code/AD2.c **** **     Component   : ADC_LDD
   7:../Generated_Code/AD2.c **** **     Version     : Component 01.115, Driver 01.07, CPU db: 3.00.001
   8:../Generated_Code/AD2.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AD2.c **** **     Date/Time   : 2013-04-11, 15:40, # CodeGen: 91
  10:../Generated_Code/AD2.c **** **     Abstract    :
  11:../Generated_Code/AD2.c **** **         This device "ADC_LDD" implements an A/D converter,
  12:../Generated_Code/AD2.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/AD2.c **** **     Settings    :
  14:../Generated_Code/AD2.c **** **          Component name                                 : AD2
  15:../Generated_Code/AD2.c **** **          A/D converter                                  : ADC1
  16:../Generated_Code/AD2.c **** **          Discontinuous mode                             : no
  17:../Generated_Code/AD2.c **** **          Converter mode                                 : Sequential
  18:../Generated_Code/AD2.c **** **          Interrupt service/event                        : Disabled
  19:../Generated_Code/AD2.c **** **          A/D channel list                               : 1
  20:../Generated_Code/AD2.c **** **            Channel 0                                    : 
  21:../Generated_Code/AD2.c **** **              Channel mode                               : Single Ended
  22:../Generated_Code/AD2.c **** **                Input                                    : 
  23:../Generated_Code/AD2.c **** **                  A/D channel (pin)                      : PTB4/FTM1_FLT0/LCD_P4/ADC1_SE10
  24:../Generated_Code/AD2.c **** **                  A/D channel (pin) signal               : 
  25:../Generated_Code/AD2.c **** **          Static sample groups                           : Disabled
  26:../Generated_Code/AD2.c **** **          A/D resolution                                 : Autoselect
  27:../Generated_Code/AD2.c **** **          Low-power mode                                 : Disabled
  28:../Generated_Code/AD2.c **** **          High-speed conversion mode                     : Disabled
  29:../Generated_Code/AD2.c **** **          Asynchro clock output                          : Disabled
  30:../Generated_Code/AD2.c **** **          Sample time                                    : 4 clock periods
  31:../Generated_Code/AD2.c **** **          Number of conversions                          : 1
  32:../Generated_Code/AD2.c **** **          Conversion time                                : 6.25 µs
  33:../Generated_Code/AD2.c **** **          ADC clock                                      : 4 MHz (250 ns)
  34:../Generated_Code/AD2.c **** **          Single conversion time - Single-ended          : 7.604 us
  35:../Generated_Code/AD2.c **** **          Single conversion time - Differential          : 9.854 us
  36:../Generated_Code/AD2.c **** **          Additional conversion time - Single-ended      : 6.25 us
  37:../Generated_Code/AD2.c **** **          Additional conversion time - Differential      : 8.5 us
  38:../Generated_Code/AD2.c **** **          Result type                                    : unsigned 16 bits, right justified
  39:../Generated_Code/AD2.c **** **          Trigger                                        : Disabled
  40:../Generated_Code/AD2.c **** **          Voltage reference                              : 
  41:../Generated_Code/AD2.c **** **            High voltage reference                       : 
  42:../Generated_Code/AD2.c **** **              Volt. ref. pin                             : VREFH
  43:../Generated_Code/AD2.c **** **              Volt. ref pin signal                       : 
  44:../Generated_Code/AD2.c **** **            Low voltage reference                        : 
  45:../Generated_Code/AD2.c **** **              Volt. ref. pin                             : VREFL
  46:../Generated_Code/AD2.c **** **              Volt. ref pin signal                       : 
  47:../Generated_Code/AD2.c **** **          Initialization                                 : 
  48:../Generated_Code/AD2.c **** **            Enabled in init. code                        : yes
  49:../Generated_Code/AD2.c **** **            Auto initialization                          : no
  50:../Generated_Code/AD2.c **** **            Event mask                                   : 
  51:../Generated_Code/AD2.c **** **              OnMeasurementComplete                      : Disabled
  52:../Generated_Code/AD2.c **** **          CPU clock/configuration selection              : 
  53:../Generated_Code/AD2.c **** **            Clock configuration 0                        : This component enabled
  54:../Generated_Code/AD2.c **** **            Clock configuration 1                        : This component disabled
  55:../Generated_Code/AD2.c **** **            Clock configuration 2                        : This component disabled
  56:../Generated_Code/AD2.c **** **            Clock configuration 3                        : This component disabled
  57:../Generated_Code/AD2.c **** **            Clock configuration 4                        : This component disabled
  58:../Generated_Code/AD2.c **** **            Clock configuration 5                        : This component disabled
  59:../Generated_Code/AD2.c **** **            Clock configuration 6                        : This component disabled
  60:../Generated_Code/AD2.c **** **            Clock configuration 7                        : This component disabled
  61:../Generated_Code/AD2.c **** **     Contents    :
  62:../Generated_Code/AD2.c **** **         Init                   - LDD_TDeviceData* AD2_Init(LDD_TUserData *UserDataPtr);
  63:../Generated_Code/AD2.c **** **         Deinit                 - void AD2_Deinit(LDD_TDeviceData *DeviceDataPtr);
  64:../Generated_Code/AD2.c **** **         StartSingleMeasurement - LDD_TError AD2_StartSingleMeasurement(LDD_TDeviceData *DeviceDa
  65:../Generated_Code/AD2.c **** **         CreateSampleGroup      - LDD_TError AD2_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr
  66:../Generated_Code/AD2.c **** **         GetMeasuredValues      - LDD_TError AD2_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr
  67:../Generated_Code/AD2.c **** **
  68:../Generated_Code/AD2.c **** **     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
  69:../Generated_Code/AD2.c **** **     
  70:../Generated_Code/AD2.c **** **     http      : www.freescale.com
  71:../Generated_Code/AD2.c **** **     mail      : support@freescale.com
  72:../Generated_Code/AD2.c **** ** ###################################################################*/
  73:../Generated_Code/AD2.c **** 
  74:../Generated_Code/AD2.c **** /* MODULE AD2. */
  75:../Generated_Code/AD2.c **** 
  76:../Generated_Code/AD2.c **** #include "AD2.h"
  77:../Generated_Code/AD2.c **** /* {Default RTOS Adapter} No RTOS includes */
  78:../Generated_Code/AD2.c **** 
  79:../Generated_Code/AD2.c **** #define AD2_AVAILABLE_CHANNEL0_31_PIN_MASK (LDD_ADC_CHANNEL_0_PIN) /* Mask of all allocated channel
  80:../Generated_Code/AD2.c **** #define AD2_AVAILABLE_CHANNEL32_63_PIN_MASK 0x00U /* Mask of all allocated channel pins from 32 to 
  81:../Generated_Code/AD2.c **** #define AD2_AVAILABLE_TRIGGER_PIN_MASK 0x00U /* Mask of all allocated trigger pins */
  82:../Generated_Code/AD2.c **** #define AD2_AVAILABLE_VOLT_REF_PIN_MASK (LDD_ADC_LOW_VOLT_REF_PIN | LDD_ADC_HIGH_VOLT_REF_PIN) /* M
  83:../Generated_Code/AD2.c **** 
  84:../Generated_Code/AD2.c **** static const uint8_t ChannelToPin[] = { /* Channel to pin conversion table */
  85:../Generated_Code/AD2.c ****   /* ADC1_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
  86:../Generated_Code/AD2.c ****   0x0AU                                /* Status and control register value */
  87:../Generated_Code/AD2.c **** };
  88:../Generated_Code/AD2.c **** 
  89:../Generated_Code/AD2.c **** typedef struct {
  90:../Generated_Code/AD2.c ****   uint8_t SampleCount;                 /* Number of samples in the last selected/created sample gro
  91:../Generated_Code/AD2.c ****   uint8_t FirstSample;                 /* First sample of group store */
  92:../Generated_Code/AD2.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
  93:../Generated_Code/AD2.c **** } AD2_TDeviceData;                     /* Device data structure type */
  94:../Generated_Code/AD2.c **** 
  95:../Generated_Code/AD2.c **** typedef AD2_TDeviceData* AD2_TDeviceDataPtr ; /* Pointer to the device data structure. */
  96:../Generated_Code/AD2.c **** 
  97:../Generated_Code/AD2.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
  98:../Generated_Code/AD2.c **** static AD2_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  99:../Generated_Code/AD2.c **** /*
 100:../Generated_Code/AD2.c **** ** ===================================================================
 101:../Generated_Code/AD2.c **** **     Method      :  AD2_Init (component ADC_LDD)
 102:../Generated_Code/AD2.c **** **
 103:../Generated_Code/AD2.c **** **     Description :
 104:../Generated_Code/AD2.c **** **         Initializes the device. Allocates memory for the device data
 105:../Generated_Code/AD2.c **** **         structure, allocates interrupt vectors and sets interrupt
 106:../Generated_Code/AD2.c **** **         priority, sets pin routing, sets timing, etc.
 107:../Generated_Code/AD2.c **** **         If the "Enable in init. code" is set to "yes" value then the
 108:../Generated_Code/AD2.c **** **         device is also enabled(see the description of the Enable()
 109:../Generated_Code/AD2.c **** **         method). In this case the Enable() method is not necessary
 110:../Generated_Code/AD2.c **** **         and needn't to be generated. 
 111:../Generated_Code/AD2.c **** **         This method can be called only once. Before the second call
 112:../Generated_Code/AD2.c **** **         of Init() the Deinit() must be called first.
 113:../Generated_Code/AD2.c **** **     Parameters  :
 114:../Generated_Code/AD2.c **** **         NAME            - DESCRIPTION
 115:../Generated_Code/AD2.c **** **       * UserDataPtr     - Pointer to the user or
 116:../Generated_Code/AD2.c **** **                           RTOS specific data. This pointer will be
 117:../Generated_Code/AD2.c **** **                           passed as an event or callback parameter.
 118:../Generated_Code/AD2.c **** **     Returns     :
 119:../Generated_Code/AD2.c **** **         ---             - Device data structure pointer.
 120:../Generated_Code/AD2.c **** ** ===================================================================
 121:../Generated_Code/AD2.c **** */
 122:../Generated_Code/AD2.c **** LDD_TDeviceData* AD2_Init(LDD_TUserData *UserDataPtr)
 123:../Generated_Code/AD2.c **** {
  39              		.loc 1 123 0
  40              		.cfi_startproc
  41              		@ args = 0, pretend = 0, frame = 16
  42              		@ frame_needed = 1, uses_anonymous_args = 0
  43              		@ link register save eliminated.
  44 0000 80B4     		push	{r7}
  45              	.LCFI0:
  46              		.cfi_def_cfa_offset 4
  47              		.cfi_offset 7, -4
  48 0002 85B0     		sub	sp, sp, #20
  49              	.LCFI1:
  50              		.cfi_def_cfa_offset 24
  51 0004 00AF     		add	r7, sp, #0
  52              	.LCFI2:
  53              		.cfi_def_cfa_register 7
  54 0006 7860     		str	r0, [r7, #4]
 124:../Generated_Code/AD2.c ****   /* Allocate LDD device structure */
 125:../Generated_Code/AD2.c ****   AD2_TDeviceDataPtr DeviceDataPrv;
 126:../Generated_Code/AD2.c **** 
 127:../Generated_Code/AD2.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 128:../Generated_Code/AD2.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  55              		.loc 1 128 0
  56 0008 40F20003 		movw	r3, #:lower16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  57 000c C0F20003 		movt	r3, #:upper16:DeviceDataPrv__DEFAULT_RTOS_ALLOC
  58 0010 FB60     		str	r3, [r7, #12]
 129:../Generated_Code/AD2.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  59              		.loc 1 129 0
  60 0012 FB68     		ldr	r3, [r7, #12]
  61 0014 7A68     		ldr	r2, [r7, #4]
  62 0016 5A60     		str	r2, [r3, #4]
 130:../Generated_Code/AD2.c ****   DeviceDataPrv->SampleCount = 0U;     /* Initializing SampleCount for right access of some methods
  63              		.loc 1 130 0
  64 0018 FB68     		ldr	r3, [r7, #12]
  65 001a 4FF00002 		mov	r2, #0
  66 001e 1A70     		strb	r2, [r3, #0]
 131:../Generated_Code/AD2.c ****   /* SIM_SCGC3: ADC1=1 */
 132:../Generated_Code/AD2.c ****   SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;                                                   
  67              		.loc 1 132 0
  68 0020 4FF4E043 		mov	r3, #28672
  69 0024 C4F20403 		movt	r3, 16388
  70 0028 4FF4E042 		mov	r2, #28672
  71 002c C4F20402 		movt	r2, 16388
  72 0030 02F58052 		add	r2, r2, #4096
  73 0034 02F13002 		add	r2, r2, #48
  74 0038 1268     		ldr	r2, [r2, #0]
  75 003a 42F00062 		orr	r2, r2, #134217728
  76 003e 03F58053 		add	r3, r3, #4096
  77 0042 03F13003 		add	r3, r3, #48
  78 0046 1A60     		str	r2, [r3, #0]
 133:../Generated_Code/AD2.c ****   /* PORTB_PCR4: ISF=0,MUX=0 */
 134:../Generated_Code/AD2.c ****   PORTB_PCR4 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));                   
  79              		.loc 1 134 0
  80 0048 4FF42043 		mov	r3, #40960
  81 004c C4F20403 		movt	r3, 16388
  82 0050 4FF42042 		mov	r2, #40960
  83 0054 C4F20402 		movt	r2, 16388
  84 0058 1269     		ldr	r2, [r2, #16]
  85 005a 22F08072 		bic	r2, r2, #16777216
  86 005e 22F4E062 		bic	r2, r2, #1792
  87 0062 1A61     		str	r2, [r3, #16]
 135:../Generated_Code/AD2.c ****   /* ADC1_CFG1: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 136:../Generated_Code/AD2.c ****   ADC1_CFG1 = (ADC_CFG1_MODE(0x03) | ADC_CFG1_ADICLK(0x02));                                       
  88              		.loc 1 136 0
  89 0064 4FF43043 		mov	r3, #45056
  90 0068 C4F20B03 		movt	r3, 16395
  91 006c 4FF00E02 		mov	r2, #14
  92 0070 9A60     		str	r2, [r3, #8]
 137:../Generated_Code/AD2.c ****   /* ADC1_CFG2: ADACKEN=0,ADHSC=0,ADLSTS=0 */
 138:../Generated_Code/AD2.c ****   ADC1_CFG2 &= (uint32_t)~(uint32_t)(
  93              		.loc 1 138 0
  94 0072 4FF43043 		mov	r3, #45056
  95 0076 C4F20B03 		movt	r3, 16395
  96 007a 4FF43042 		mov	r2, #45056
  97 007e C4F20B02 		movt	r2, 16395
  98 0082 D268     		ldr	r2, [r2, #12]
  99 0084 22F00F02 		bic	r2, r2, #15
 100 0088 DA60     		str	r2, [r3, #12]
 139:../Generated_Code/AD2.c ****                 ADC_CFG2_ADACKEN_MASK |
 140:../Generated_Code/AD2.c ****                 ADC_CFG2_ADHSC_MASK |
 141:../Generated_Code/AD2.c ****                 ADC_CFG2_ADLSTS(0x03)
 142:../Generated_Code/AD2.c ****                );                                                   
 143:../Generated_Code/AD2.c ****   /* ADC1_SC2: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 144:../Generated_Code/AD2.c ****   ADC1_SC2 = 0x00U;                                                   
 101              		.loc 1 144 0
 102 008a 4FF43043 		mov	r3, #45056
 103 008e C4F20B03 		movt	r3, 16395
 104 0092 4FF00002 		mov	r2, #0
 105 0096 1A62     		str	r2, [r3, #32]
 145:../Generated_Code/AD2.c ****   /* ADC1_SC3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 146:../Generated_Code/AD2.c ****   ADC1_SC3 = ADC_SC3_CALF_MASK;                                                   
 106              		.loc 1 146 0
 107 0098 4FF43043 		mov	r3, #45056
 108 009c C4F20B03 		movt	r3, 16395
 109 00a0 4FF04002 		mov	r2, #64
 110 00a4 5A62     		str	r2, [r3, #36]
 147:../Generated_Code/AD2.c ****   /* Registration of the device structure */
 148:../Generated_Code/AD2.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_AD2_ID,DeviceDataPrv);
 111              		.loc 1 148 0
 112 00a6 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 113 00aa C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 114 00ae FA68     		ldr	r2, [r7, #12]
 115 00b0 1A62     		str	r2, [r3, #32]
 149:../Generated_Code/AD2.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 116              		.loc 1 149 0
 117 00b2 FB68     		ldr	r3, [r7, #12]
 150:../Generated_Code/AD2.c **** }
 118              		.loc 1 150 0
 119 00b4 1846     		mov	r0, r3
 120 00b6 07F11407 		add	r7, r7, #20
 121 00ba BD46     		mov	sp, r7
 122 00bc 80BC     		pop	{r7}
 123 00be 7047     		bx	lr
 124              		.cfi_endproc
 125              	.LFE0:
 127              		.section	.text.AD2_Deinit,"ax",%progbits
 128              		.align	2
 129              		.global	AD2_Deinit
 130              		.thumb
 131              		.thumb_func
 133              	AD2_Deinit:
 134              	.LFB1:
 151:../Generated_Code/AD2.c **** 
 152:../Generated_Code/AD2.c **** /*
 153:../Generated_Code/AD2.c **** ** ===================================================================
 154:../Generated_Code/AD2.c **** **     Method      :  AD2_Deinit (component ADC_LDD)
 155:../Generated_Code/AD2.c **** **
 156:../Generated_Code/AD2.c **** **     Description :
 157:../Generated_Code/AD2.c **** **         Deinitializes the device. Switches off the device, frees the
 158:../Generated_Code/AD2.c **** **         device data structure memory, interrupts vectors, etc.
 159:../Generated_Code/AD2.c **** **     Parameters  :
 160:../Generated_Code/AD2.c **** **         NAME            - DESCRIPTION
 161:../Generated_Code/AD2.c **** **       * DeviceDataPtr   - Device data structure
 162:../Generated_Code/AD2.c **** **                           pointer returned by <Init> method.
 163:../Generated_Code/AD2.c **** **     Returns     : Nothing
 164:../Generated_Code/AD2.c **** ** ===================================================================
 165:../Generated_Code/AD2.c **** */
 166:../Generated_Code/AD2.c **** void AD2_Deinit(LDD_TDeviceData *DeviceDataPtr)
 167:../Generated_Code/AD2.c **** {
 135              		.loc 1 167 0
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 8
 138              		@ frame_needed = 1, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140 0000 80B4     		push	{r7}
 141              	.LCFI3:
 142              		.cfi_def_cfa_offset 4
 143              		.cfi_offset 7, -4
 144 0002 83B0     		sub	sp, sp, #12
 145              	.LCFI4:
 146              		.cfi_def_cfa_offset 16
 147 0004 00AF     		add	r7, sp, #0
 148              	.LCFI5:
 149              		.cfi_def_cfa_register 7
 150 0006 7860     		str	r0, [r7, #4]
 168:../Generated_Code/AD2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 169:../Generated_Code/AD2.c ****   /* ADC1_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 170:../Generated_Code/AD2.c ****   ADC1_SC1A = ADC_SC1_ADCH(0x1F);                                                   
 151              		.loc 1 170 0
 152 0008 4FF43043 		mov	r3, #45056
 153 000c C4F20B03 		movt	r3, 16395
 154 0010 4FF01F02 		mov	r2, #31
 155 0014 1A60     		str	r2, [r3, #0]
 171:../Generated_Code/AD2.c ****   /* Unregistration of the device structure */
 172:../Generated_Code/AD2.c ****   PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_AD2_ID);
 156              		.loc 1 172 0
 157 0016 40F20003 		movw	r3, #:lower16:PE_LDD_DeviceDataList
 158 001a C0F20003 		movt	r3, #:upper16:PE_LDD_DeviceDataList
 159 001e 4FF00002 		mov	r2, #0
 160 0022 1A62     		str	r2, [r3, #32]
 173:../Generated_Code/AD2.c ****   /* Deallocation of the device structure */
 174:../Generated_Code/AD2.c ****   /* {Default RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no dealloc
 175:../Generated_Code/AD2.c ****   /* SIM_SCGC3: ADC1=0 */
 176:../Generated_Code/AD2.c ****   SIM_SCGC3 &= (uint32_t)~(uint32_t)(SIM_SCGC3_ADC1_MASK);                                         
 161              		.loc 1 176 0
 162 0024 4FF4E043 		mov	r3, #28672
 163 0028 C4F20403 		movt	r3, 16388
 164 002c 4FF4E042 		mov	r2, #28672
 165 0030 C4F20402 		movt	r2, 16388
 166 0034 02F58052 		add	r2, r2, #4096
 167 0038 02F13002 		add	r2, r2, #48
 168 003c 1268     		ldr	r2, [r2, #0]
 169 003e 22F00062 		bic	r2, r2, #134217728
 170 0042 03F58053 		add	r3, r3, #4096
 171 0046 03F13003 		add	r3, r3, #48
 172 004a 1A60     		str	r2, [r3, #0]
 177:../Generated_Code/AD2.c **** }
 173              		.loc 1 177 0
 174 004c 07F10C07 		add	r7, r7, #12
 175 0050 BD46     		mov	sp, r7
 176 0052 80BC     		pop	{r7}
 177 0054 7047     		bx	lr
 178              		.cfi_endproc
 179              	.LFE1:
 181 0056 00BF     		.section	.text.AD2_StartSingleMeasurement,"ax",%progbits
 182              		.align	2
 183              		.global	AD2_StartSingleMeasurement
 184              		.thumb
 185              		.thumb_func
 187              	AD2_StartSingleMeasurement:
 188              	.LFB2:
 178:../Generated_Code/AD2.c **** 
 179:../Generated_Code/AD2.c **** /*
 180:../Generated_Code/AD2.c **** ** ===================================================================
 181:../Generated_Code/AD2.c **** **     Method      :  AD2_StartSingleMeasurement (component ADC_LDD)
 182:../Generated_Code/AD2.c **** **
 183:../Generated_Code/AD2.c **** **     Description :
 184:../Generated_Code/AD2.c **** **         This method starts one measurement of the selected group of
 185:../Generated_Code/AD2.c **** **         samples and exits immediately. The group of samples for
 186:../Generated_Code/AD2.c **** **         measurement is specified by preceding call to
 187:../Generated_Code/AD2.c **** **         <SelectSampleGroup()> or <SelectSampleGroup()> method. The
 188:../Generated_Code/AD2.c **** **         <OnMeasurementComplete() > event is invoked after the
 189:../Generated_Code/AD2.c **** **         measurement is done and the event is enabled. The state of
 190:../Generated_Code/AD2.c **** **         the measurement can be also polled by the
 191:../Generated_Code/AD2.c **** **         <GetMeasurementCompleteStatus()> method. Results of the
 192:../Generated_Code/AD2.c **** **         measurement can be read by the <GetMeasuredValues()> method.
 193:../Generated_Code/AD2.c **** **         The <Discontinuous mode> doesn't support this method.
 194:../Generated_Code/AD2.c **** **     Parameters  :
 195:../Generated_Code/AD2.c **** **         NAME            - DESCRIPTION
 196:../Generated_Code/AD2.c **** **       * DeviceDataPtr   - Device data structure
 197:../Generated_Code/AD2.c **** **                           pointer returned by <Init> method.
 198:../Generated_Code/AD2.c **** **     Returns     :
 199:../Generated_Code/AD2.c **** **         ---             - Error code, possible codes:
 200:../Generated_Code/AD2.c **** **                           ERR_OK - OK
 201:../Generated_Code/AD2.c **** **                           ERR_SPEED - The device doesn't work in the
 202:../Generated_Code/AD2.c **** **                           active clock configuration
 203:../Generated_Code/AD2.c **** **                           ERR_DISABLED - Component is disabled
 204:../Generated_Code/AD2.c **** **                           ERR_BUSY - A measurement is in progress 
 205:../Generated_Code/AD2.c **** ** ===================================================================
 206:../Generated_Code/AD2.c **** */
 207:../Generated_Code/AD2.c **** LDD_TError AD2_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr)
 208:../Generated_Code/AD2.c **** {
 189              		.loc 1 208 0
 190              		.cfi_startproc
 191              		@ args = 0, pretend = 0, frame = 8
 192              		@ frame_needed = 1, uses_anonymous_args = 0
 193              		@ link register save eliminated.
 194 0000 80B4     		push	{r7}
 195              	.LCFI6:
 196              		.cfi_def_cfa_offset 4
 197              		.cfi_offset 7, -4
 198 0002 83B0     		sub	sp, sp, #12
 199              	.LCFI7:
 200              		.cfi_def_cfa_offset 16
 201 0004 00AF     		add	r7, sp, #0
 202              	.LCFI8:
 203              		.cfi_def_cfa_register 7
 204 0006 7860     		str	r0, [r7, #4]
 209:../Generated_Code/AD2.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 210:../Generated_Code/AD2.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC1_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 205              		.loc 1 210 0
 206 0008 4FF43043 		mov	r3, #45056
 207 000c C4F20B03 		movt	r3, 16395
 208 0010 1B6A     		ldr	r3, [r3, #32]
 209 0012 03F08003 		and	r3, r3, #128
 210 0016 002B     		cmp	r3, #0
 211 0018 02D0     		beq	.L4
 211:../Generated_Code/AD2.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 212              		.loc 1 211 0
 213 001a 4FF00803 		mov	r3, #8
 214 001e 20E0     		b	.L5
 215              	.L4:
 212:../Generated_Code/AD2.c ****   }
 213:../Generated_Code/AD2.c ****   ADC_PDD_SetContinuousMode(ADC1_BASE_PTR, ADC_PDD_ONE_CONVERSION); /* Set one conversion mode */
 216              		.loc 1 213 0
 217 0020 4FF43043 		mov	r3, #45056
 218 0024 C4F20B03 		movt	r3, 16395
 219 0028 4FF43042 		mov	r2, #45056
 220 002c C4F20B02 		movt	r2, 16395
 221 0030 526A     		ldr	r2, [r2, #36]
 222 0032 22F00802 		bic	r2, r2, #8
 223 0036 5A62     		str	r2, [r3, #36]
 214:../Generated_Code/AD2.c ****   ADC_PDD_SetConversionTriggerType(ADC1_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 224              		.loc 1 214 0
 225 0038 4FF43043 		mov	r3, #45056
 226 003c C4F20B03 		movt	r3, 16395
 227 0040 4FF43042 		mov	r2, #45056
 228 0044 C4F20B02 		movt	r2, 16395
 229 0048 126A     		ldr	r2, [r2, #32]
 230 004a 22F04002 		bic	r2, r2, #64
 231 004e 1A62     		str	r2, [r3, #32]
 215:../Generated_Code/AD2.c ****   ADC_PDD_WriteStatusControl1Reg(ADC1_BASE_PTR, 0U, ((AD2_TDeviceDataPtr)DeviceDataPtr)->FirstSampl
 232              		.loc 1 215 0
 233 0050 4FF43043 		mov	r3, #45056
 234 0054 C4F20B03 		movt	r3, 16395
 235 0058 7A68     		ldr	r2, [r7, #4]
 236 005a 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 237 005c 1A60     		str	r2, [r3, #0]
 216:../Generated_Code/AD2.c ****   return ERR_OK;                       /* OK */
 238              		.loc 1 216 0
 239 005e 4FF00003 		mov	r3, #0
 240              	.L5:
 217:../Generated_Code/AD2.c **** }
 241              		.loc 1 217 0
 242 0062 1846     		mov	r0, r3
 243 0064 07F10C07 		add	r7, r7, #12
 244 0068 BD46     		mov	sp, r7
 245 006a 80BC     		pop	{r7}
 246 006c 7047     		bx	lr
 247              		.cfi_endproc
 248              	.LFE2:
 250 006e 00BF     		.section	.text.AD2_CreateSampleGroup,"ax",%progbits
 251              		.align	2
 252              		.global	AD2_CreateSampleGroup
 253              		.thumb
 254              		.thumb_func
 256              	AD2_CreateSampleGroup:
 257              	.LFB3:
 218:../Generated_Code/AD2.c **** 
 219:../Generated_Code/AD2.c **** /*
 220:../Generated_Code/AD2.c **** ** ===================================================================
 221:../Generated_Code/AD2.c **** **     Method      :  AD2_CreateSampleGroup (component ADC_LDD)
 222:../Generated_Code/AD2.c **** **
 223:../Generated_Code/AD2.c **** **     Description :
 224:../Generated_Code/AD2.c **** **         This method prepares HW for next measurement according to
 225:../Generated_Code/AD2.c **** **         array of samples defined during run-time. The array of
 226:../Generated_Code/AD2.c **** **         samples should be prepared prior to calling this method.
 227:../Generated_Code/AD2.c **** **         Pointer to the array is passed into this method in parameter
 228:../Generated_Code/AD2.c **** **         SampleGroupPtr. The number of samples is defined by
 229:../Generated_Code/AD2.c **** **         parameter SampleCount. Once any group is prepared, the
 230:../Generated_Code/AD2.c **** **         measurement can be started multiple times. Note: This method
 231:../Generated_Code/AD2.c **** **         works only with the sample groups defined during run-time.
 232:../Generated_Code/AD2.c **** **         For design-time defined groups use <SelectSampleGroup()>
 233:../Generated_Code/AD2.c **** **         method.
 234:../Generated_Code/AD2.c **** **     Parameters  :
 235:../Generated_Code/AD2.c **** **         NAME            - DESCRIPTION
 236:../Generated_Code/AD2.c **** **       * DeviceDataPtr   - Device data structure
 237:../Generated_Code/AD2.c **** **                           pointer returned by <Init> method.
 238:../Generated_Code/AD2.c **** **       * SampleGroupPtr  - Pointer to the
 239:../Generated_Code/AD2.c **** **                           sample definition array. This array can be
 240:../Generated_Code/AD2.c **** **                           released as soon as the method ends.
 241:../Generated_Code/AD2.c **** **         SampleCount     - Number of items in the
 242:../Generated_Code/AD2.c **** **                           sample definition array. Must be less than
 243:../Generated_Code/AD2.c **** **                           or equal to
 244:../Generated_Code/AD2.c **** **                           ComponentName_MAX_HW_SAMPLE_COUNT.
 245:../Generated_Code/AD2.c **** **     Returns     :
 246:../Generated_Code/AD2.c **** **         ---             - Error code, possible codes:
 247:../Generated_Code/AD2.c **** **                           ERR_OK - OK
 248:../Generated_Code/AD2.c **** **                           ERR_SPEED - The device doesn't work in the
 249:../Generated_Code/AD2.c **** **                           active clock configuration
 250:../Generated_Code/AD2.c **** **                           ERR_DISABLED - Component is disabled
 251:../Generated_Code/AD2.c **** **                           ERR_PARAM_INDEX - Channel index in
 252:../Generated_Code/AD2.c **** **                           SampleGroup structure is out of range
 253:../Generated_Code/AD2.c **** **                           ERR_PARAM_SAMPLE_COUNT - SampleCount
 254:../Generated_Code/AD2.c **** **                           variable value is out of range
 255:../Generated_Code/AD2.c **** **                           ERR_BUSY - Measurement is in progress 
 256:../Generated_Code/AD2.c **** ** ===================================================================
 257:../Generated_Code/AD2.c **** */
 258:../Generated_Code/AD2.c **** LDD_TError AD2_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr, LDD_ADC_TSample *SampleGroupPtr, u
 259:../Generated_Code/AD2.c **** {
 258              		.loc 1 259 0
 259              		.cfi_startproc
 260              		@ args = 0, pretend = 0, frame = 24
 261              		@ frame_needed = 1, uses_anonymous_args = 0
 262              		@ link register save eliminated.
 263 0000 80B4     		push	{r7}
 264              	.LCFI9:
 265              		.cfi_def_cfa_offset 4
 266              		.cfi_offset 7, -4
 267 0002 87B0     		sub	sp, sp, #28
 268              	.LCFI10:
 269              		.cfi_def_cfa_offset 32
 270 0004 00AF     		add	r7, sp, #0
 271              	.LCFI11:
 272              		.cfi_def_cfa_register 7
 273 0006 F860     		str	r0, [r7, #12]
 274 0008 B960     		str	r1, [r7, #8]
 275 000a 1346     		mov	r3, r2
 276 000c FB71     		strb	r3, [r7, #7]
 260:../Generated_Code/AD2.c ****   AD2_TDeviceDataPtr DeviceDataPrv = (AD2_TDeviceDataPtr)DeviceDataPtr;
 277              		.loc 1 260 0
 278 000e FB68     		ldr	r3, [r7, #12]
 279 0010 7B61     		str	r3, [r7, #20]
 261:../Generated_Code/AD2.c **** 
 262:../Generated_Code/AD2.c ****   /* Sample count test - this test can be disabled by setting the "Ignore range checking"
 263:../Generated_Code/AD2.c ****      property to the "yes" value in the "Configuration inspector" */
 264:../Generated_Code/AD2.c ****   if ((SampleCount > AD2_MAX_HW_SAMPLE_COUNT) || (SampleCount == 0U)) { /* Is number of sample grea
 280              		.loc 1 264 0
 281 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 282 0014 012B     		cmp	r3, #1
 283 0016 02D8     		bhi	.L7
 284              		.loc 1 264 0 is_stmt 0 discriminator 1
 285 0018 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 286 001a 002B     		cmp	r3, #0
 287 001c 02D1     		bne	.L8
 288              	.L7:
 265:../Generated_Code/AD2.c ****     return ERR_PARAM_SAMPLE_COUNT;     /* Yes, return ERR_PARAM_SAMPLE_COUNT */
 289              		.loc 1 265 0 is_stmt 1
 290 001e 4FF09603 		mov	r3, #150
 291 0022 21E0     		b	.L9
 292              	.L8:
 266:../Generated_Code/AD2.c ****   }
 267:../Generated_Code/AD2.c ****   if ((ADC_PDD_GetConversionActiveFlag(ADC1_BASE_PTR) != 0U)) { /* Last measurement still pending? 
 293              		.loc 1 267 0
 294 0024 4FF43043 		mov	r3, #45056
 295 0028 C4F20B03 		movt	r3, 16395
 296 002c 1B6A     		ldr	r3, [r3, #32]
 297 002e 03F08003 		and	r3, r3, #128
 298 0032 002B     		cmp	r3, #0
 299 0034 02D0     		beq	.L10
 268:../Generated_Code/AD2.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 300              		.loc 1 268 0
 301 0036 4FF00803 		mov	r3, #8
 302 003a 15E0     		b	.L9
 303              	.L10:
 269:../Generated_Code/AD2.c ****   }
 270:../Generated_Code/AD2.c ****   DeviceDataPrv->SampleCount = SampleCount; /* Remember sample count */
 304              		.loc 1 270 0
 305 003c 7B69     		ldr	r3, [r7, #20]
 306 003e FA79     		ldrb	r2, [r7, #7]
 307 0040 1A70     		strb	r2, [r3, #0]
 271:../Generated_Code/AD2.c ****   /* Channel index test - this test can be disabled by setting the "Ignore range checking"
 272:../Generated_Code/AD2.c ****      property to the "yes" value in the "Configuration inspector" */
 273:../Generated_Code/AD2.c ****   if (SampleGroupPtr[0].ChannelIdx >= AD2_CHANNEL_COUNT) { /* Is channel index out of range? */
 308              		.loc 1 273 0
 309 0042 BB68     		ldr	r3, [r7, #8]
 310 0044 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 311 0046 002B     		cmp	r3, #0
 312 0048 02D0     		beq	.L11
 274:../Generated_Code/AD2.c ****     return ERR_PARAM_INDEX;            /* Yes, return ERR_PARAM_INDEX */
 313              		.loc 1 274 0
 314 004a 4FF08203 		mov	r3, #130
 315 004e 0BE0     		b	.L9
 316              	.L11:
 275:../Generated_Code/AD2.c ****   }
 276:../Generated_Code/AD2.c ****   DeviceDataPrv->FirstSample = ChannelToPin[SampleGroupPtr[0].ChannelIdx]; /* Remember first sample
 317              		.loc 1 276 0
 318 0050 BB68     		ldr	r3, [r7, #8]
 319 0052 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 320 0054 1A46     		mov	r2, r3
 321 0056 40F20003 		movw	r3, #:lower16:ChannelToPin
 322 005a C0F20003 		movt	r3, #:upper16:ChannelToPin
 323 005e 9A5C     		ldrb	r2, [r3, r2]	@ zero_extendqisi2
 324 0060 7B69     		ldr	r3, [r7, #20]
 325 0062 5A70     		strb	r2, [r3, #1]
 277:../Generated_Code/AD2.c ****   return ERR_OK;                       /* OK */
 326              		.loc 1 277 0
 327 0064 4FF00003 		mov	r3, #0
 328              	.L9:
 278:../Generated_Code/AD2.c **** }
 329              		.loc 1 278 0
 330 0068 1846     		mov	r0, r3
 331 006a 07F11C07 		add	r7, r7, #28
 332 006e BD46     		mov	sp, r7
 333 0070 80BC     		pop	{r7}
 334 0072 7047     		bx	lr
 335              		.cfi_endproc
 336              	.LFE3:
 338              		.section	.text.AD2_GetMeasuredValues,"ax",%progbits
 339              		.align	2
 340              		.global	AD2_GetMeasuredValues
 341              		.thumb
 342              		.thumb_func
 344              	AD2_GetMeasuredValues:
 345              	.LFB4:
 279:../Generated_Code/AD2.c **** 
 280:../Generated_Code/AD2.c **** /*
 281:../Generated_Code/AD2.c **** ** ===================================================================
 282:../Generated_Code/AD2.c **** **     Method      :  AD2_GetMeasuredValues (component ADC_LDD)
 283:../Generated_Code/AD2.c **** **
 284:../Generated_Code/AD2.c **** **     Description :
 285:../Generated_Code/AD2.c **** **         This method copies results of the last measurement to the
 286:../Generated_Code/AD2.c **** **         user supplied buffer. Data size depends on the size of
 287:../Generated_Code/AD2.c **** **         measured sample group (see <SelectSampleGroup()> or
 288:../Generated_Code/AD2.c **** **         <CreateSampleGroup()> method). Data representation is
 289:../Generated_Code/AD2.c **** **         defined by the <Result type> property. Typically this method
 290:../Generated_Code/AD2.c **** **         is called from <OnMeasurementComplete> event to get results
 291:../Generated_Code/AD2.c **** **         of the last measurement.
 292:../Generated_Code/AD2.c **** **     Parameters  :
 293:../Generated_Code/AD2.c **** **         NAME            - DESCRIPTION
 294:../Generated_Code/AD2.c **** **       * DeviceDataPtr   - Device data structure
 295:../Generated_Code/AD2.c **** **                           pointer returned by <Init> method.
 296:../Generated_Code/AD2.c **** **       * BufferPtr       - Pointer to the start of the
 297:../Generated_Code/AD2.c **** **                           buffer for new results. Count of stored
 298:../Generated_Code/AD2.c **** **                           measured values equals to the count of the
 299:../Generated_Code/AD2.c **** **                           samples in the active sample group. It is
 300:../Generated_Code/AD2.c **** **                           in the user responsibility to provide
 301:../Generated_Code/AD2.c **** **                           buffer with appropriate size.
 302:../Generated_Code/AD2.c **** **     Returns     :
 303:../Generated_Code/AD2.c **** **         ---             - Error code, possible codes:
 304:../Generated_Code/AD2.c **** **                           ERR_OK - OK
 305:../Generated_Code/AD2.c **** **                           ERR_SPEED - The device doesn't work in the
 306:../Generated_Code/AD2.c **** **                           active clock configuration
 307:../Generated_Code/AD2.c **** **                           ERR_DISABLED - Component is disabled
 308:../Generated_Code/AD2.c **** ** ===================================================================
 309:../Generated_Code/AD2.c **** */
 310:../Generated_Code/AD2.c **** LDD_TError AD2_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr)
 311:../Generated_Code/AD2.c **** {
 346              		.loc 1 311 0
 347              		.cfi_startproc
 348              		@ args = 0, pretend = 0, frame = 16
 349              		@ frame_needed = 1, uses_anonymous_args = 0
 350              		@ link register save eliminated.
 351 0000 80B4     		push	{r7}
 352              	.LCFI12:
 353              		.cfi_def_cfa_offset 4
 354              		.cfi_offset 7, -4
 355 0002 85B0     		sub	sp, sp, #20
 356              	.LCFI13:
 357              		.cfi_def_cfa_offset 24
 358 0004 00AF     		add	r7, sp, #0
 359              	.LCFI14:
 360              		.cfi_def_cfa_register 7
 361 0006 7860     		str	r0, [r7, #4]
 362 0008 3960     		str	r1, [r7, #0]
 312:../Generated_Code/AD2.c ****   uint8_t Sample;
 313:../Generated_Code/AD2.c ****   AD2_TResultData *pBuffer = (AD2_TResultData *)BufferPtr;
 363              		.loc 1 313 0
 364 000a 3B68     		ldr	r3, [r7, #0]
 365 000c BB60     		str	r3, [r7, #8]
 314:../Generated_Code/AD2.c **** 
 315:../Generated_Code/AD2.c ****   /* Copy values from result registers defined in the active sample
 316:../Generated_Code/AD2.c ****      group to the user supplied buffer */
 317:../Generated_Code/AD2.c ****   for (Sample = 0U; Sample < ((AD2_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 366              		.loc 1 317 0
 367 000e 4FF00003 		mov	r3, #0
 368 0012 FB73     		strb	r3, [r7, #15]
 369 0014 13E0     		b	.L13
 370              	.L14:
 318:../Generated_Code/AD2.c ****     pBuffer[Sample] = (uint16_t)(ADC_PDD_GetResultValueRaw(ADC1_BASE_PTR, Sample));
 371              		.loc 1 318 0 discriminator 2
 372 0016 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 373 0018 4FEA4303 		lsl	r3, r3, #1
 374 001c BA68     		ldr	r2, [r7, #8]
 375 001e D218     		adds	r2, r2, r3
 376 0020 4FF43043 		mov	r3, #45056
 377 0024 C4F20B03 		movt	r3, 16395
 378 0028 F97B     		ldrb	r1, [r7, #15]	@ zero_extendqisi2
 379 002a 01F10401 		add	r1, r1, #4
 380 002e 53F82130 		ldr	r3, [r3, r1, lsl #2]
 381 0032 9BB2     		uxth	r3, r3
 382 0034 1380     		strh	r3, [r2, #0]	@ movhi
 317:../Generated_Code/AD2.c ****   for (Sample = 0U; Sample < ((AD2_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 383              		.loc 1 317 0 discriminator 2
 384 0036 FB7B     		ldrb	r3, [r7, #15]
 385 0038 03F10103 		add	r3, r3, #1
 386 003c FB73     		strb	r3, [r7, #15]
 387              	.L13:
 317:../Generated_Code/AD2.c ****   for (Sample = 0U; Sample < ((AD2_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 388              		.loc 1 317 0 is_stmt 0 discriminator 1
 389 003e 7B68     		ldr	r3, [r7, #4]
 390 0040 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 391 0042 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 392 0044 9A42     		cmp	r2, r3
 393 0046 E6D3     		bcc	.L14
 319:../Generated_Code/AD2.c ****   }
 320:../Generated_Code/AD2.c ****   return ERR_OK;                       /* OK */
 394              		.loc 1 320 0 is_stmt 1
 395 0048 4FF00003 		mov	r3, #0
 321:../Generated_Code/AD2.c **** }
 396              		.loc 1 321 0
 397 004c 1846     		mov	r0, r3
 398 004e 07F11407 		add	r7, r7, #20
 399 0052 BD46     		mov	sp, r7
 400 0054 80BC     		pop	{r7}
 401 0056 7047     		bx	lr
 402              		.cfi_endproc
 403              	.LFE4:
 405              		.text
 406              	.Letext0:
 407              		.file 2 "C:/Freescale/CW MCU v10.3_121211/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 408              		.file 3 "../Generated_Code/IO_Map.h"
 409              		.file 4 "../Generated_Code/PE_LDD.h"
 410              		.file 5 "../Generated_Code/AD2.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AD2.c
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:19     .rodata.ChannelToPin:00000000 $d
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:22     .rodata.ChannelToPin:00000000 ChannelToPin
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:25     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:28     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:31     .text.AD2_Init:00000000 $t
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:36     .text.AD2_Init:00000000 AD2_Init
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:128    .text.AD2_Deinit:00000000 $t
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:133    .text.AD2_Deinit:00000000 AD2_Deinit
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:182    .text.AD2_StartSingleMeasurement:00000000 $t
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:187    .text.AD2_StartSingleMeasurement:00000000 AD2_StartSingleMeasurement
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:251    .text.AD2_CreateSampleGroup:00000000 $t
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:256    .text.AD2_CreateSampleGroup:00000000 AD2_CreateSampleGroup
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:339    .text.AD2_GetMeasuredValues:00000000 $t
C:\Users\z\AppData\Local\Temp\ccTh6Esy.s:344    .text.AD2_GetMeasuredValues:00000000 AD2_GetMeasuredValues
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
